{"./":{"url":"./","title":"序言","keywords":"","body":"Golang 学习笔记 本系列是 Golang 学习笔记 更多的学习笔记请参考： Kubernetes 学习笔记 Golang 学习笔记 Linux 学习笔记 数据结构学习笔记 个人博客：www.huweihuang.com 目录 前言 序言 Golang资源 计算机语言概述 安装与配置 Golang介绍 Golang安装 包管理工具 go modules的使用 dep的使用 govendor的使用 glide的使用 顺序编程 变量与常量 数据类型 流程语句 函数与闭包 错误处理 面向对象编程 概述 类与方法 接口 接口概述 client-go中接口 通用接口设计 指针 并发编程 并发基础 Goroutine Channel 并行化 原理篇 Goroutine调度 文本处理 Json处理 文件操作 字符串处理 模板语法 测试与调试 单元测试 GDB调试 框架与工具 Cobra cobra 介绍 cobra command cobra flags Web 编程 Beego Beego 介绍 Bee 工具使用 Beego 项目逻辑 Beego 日志处理 Http包源码分析 源码分析 confd源码分析 赞赏 如果觉得文章有帮助的话，可以打赏一下，谢谢！ Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 20:00:50 "},"summary/go-resource.html":{"url":"summary/go-resource.html","title":"Golang资源","keywords":"","body":" 本文主要记录一些Golang相关的资源链接和书籍 1. 官方文档 1.1. 官网 https://golang.org/ https://golang.org/doc/ 1.2. 基础 A Tour of Go Effective Go Frequently Asked Questions (FAQ) CodeReviewComments 1.3. 补充 Diagnostics The Go Wiki Language Specification The Go Memory Model Go Playground awesome-go.com 1.4. The Go Blog Share Memory by Communicating Defer, Panic, and Recover Go Slices: usage and internals Profiling Go Programs 2. 书籍 《The Go Programming Language》 《Mastering Go》 《Go语言实战》 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 17:50:50 "},"summary/language.html":{"url":"summary/language.html","title":"计算机语言概述","keywords":"","body":"1. 计算机语言概述 学习一门计算机语言，将计算机语言分为以下几大部分： 语言特点 环境准备 基本语法 数据类型 变量 常量 引用类型 流程语句 判断语句 循环语句 选择语句 函数 面向对象编程 封装（类与方法） 继承 多态（接口） 并发编程 特殊属性 包管理 标准库 2. 思维导图 图片 - 计算机语言 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 17:50:43 "},"introduction/golang.html":{"url":"introduction/golang.html","title":"Golang介绍","keywords":"","body":"初识Go语言 1. 概述 一个在语言层面实现了并发机制的类C通用型编程语言。 2. Go关键字（25个） 类别 关键字 说明 程序声明 package，import 包的声明和导入 声明与定义 var，const 变量和常量的声明 type 用于定义类型 复合数据类型 struct 定义结构体，类似java中的class interface 定义接口 map 定义键值对 func 定义函数和方法 chan 定义管道，并发中channel通信 并发编程 go 并发编程 select 用于选择不同类型通信 流程语句 for；if，else；switch，case 循环语句；条件语句；选择语句 break，continue，fallthrough，default，goto 跳转语句等 return 函数返回值 defer 延迟函数，用于return前释放资源 range 用于读取slice，map，channel容器类数据 3. Go语言命令 Usage：go command [arguments] 分类 命令 说明 build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information fix run go tool fix on packages fmt run gofmt on package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages tool run specified go tool version print Go version vet run go tool vet on packages Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 17:33:58 "},"introduction/install.html":{"url":"introduction/install.html","title":"Golang安装","keywords":"","body":"1. install-go.sh #!/bin/bash # for linux set -x set -e # default version: 1.10.3 VERSION=$1 VERSION=${VERSION:-1.10.3} GOROOT=\"/usr/local/go\" GOPATH=$HOME/gopath # download and install wget https://dl.google.com/go/go${VERSION}.linux-amd64.tar.gz tar -C /usr/local -xzf go${VERSION}.linux-amd64.tar.gz # set golang env cat >> $HOME/.bashrc 2. 安装 chmod +x install-go.sh ./install-go.sh 1.10.3 更多版本号可参考：https://golang.org/dl/ 参考： https://golang.org/doc/install Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"introduction/package/go-modules.html":{"url":"introduction/package/go-modules.html","title":"go modules的使用","keywords":"","body":"1. Go modules简介 Go 1.11版本开始支持Go modules方式的依赖包管理功能，官网参考：https://github.com/golang/go/wiki/Modules。 2. go mod的使用 项目文件如下： hello.go package main import ( \"fmt\" \"rsc.io/quote\" ) func main() { fmt.Println(quote.Hello()) } 操作记录： # 安装GO 1.11及以上版本 go version go version go1.12.5 darwin/amd64 # 开启module功能 export GO111MODULE=on # 进入到项目目录 cd /home/gopath/src/hello # 初始化 go mod init go: creating new go.mod: module hello # 编译 go build go: finding rsc.io/quote v1.5.2 go: downloading rsc.io/quote v1.5.2 go: extracting rsc.io/quote v1.5.2 go: finding rsc.io/sampler v1.3.0 go: finding golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c go: downloading rsc.io/sampler v1.3.0 go: extracting rsc.io/sampler v1.3.0 go: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c go: extracting golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c # 加载依赖包，自动归档到vendor目录 go mod vendor -v # 命令输出如下: # golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c golang.org/x/text/language golang.org/x/text/internal/tag # rsc.io/quote v1.5.2 rsc.io/quote # rsc.io/sampler v1.3.0 rsc.io/sampler # 文件目录结构 ./ ├── go.mod ├── go.sum ├── hello # 二进制文件 ├── hello.go └── vendor ├── golang.org ├── modules.txt └── rsc.io 3. go mod的相关文件 3.1. go.mod 文件路径：项目根目录下 module hello go 1.12 require rsc.io/quote v1.5.2 3.2. go.sum 文件路径：项目根目录下 golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8= golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ= rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y= rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0= rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4= rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA= 3.3. modules.txt 文件路径：/{project}/vendor/modules.txt # golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c golang.org/x/text/language golang.org/x/text/internal/tag # rsc.io/quote v1.5.2 rsc.io/quote # rsc.io/sampler v1.3.0 rsc.io/sampler 4. go mod的帮助信息 go help mod Go mod provides access to operations on modules. Note that support for modules is built into all the go commands, not just 'go mod'. For example, day-to-day adding, removing, upgrading, and downgrading of dependencies should be done using 'go get'. See 'go help modules' for an overview of module functionality. Usage: go mod [arguments] The commands are: download download modules to local cache edit edit go.mod from tools or scripts graph print module requirement graph init initialize new module in current directory tidy add missing and remove unused modules vendor make vendored copy of dependencies verify verify dependencies have expected content why explain why packages or modules are needed Use \"go help mod \" for more information about a command. 4.1. go mod init go help mod init usage: go mod init [module] Init initializes and writes a new go.mod to the current directory, in effect creating a new module rooted at the current directory. The file go.mod must not already exist. If possible, init will guess the module path from import comments (see 'go help importpath') or from version control configuration. To override this guess, supply the module path as an argument. 4.2. go mod vendor go help mod vendor usage: go mod vendor [-v] Vendor resets the main module's vendor directory to include all packages needed to build and test all the main module's packages. It does not include test code for vendored packages. The -v flag causes vendor to print the names of vendored modules and packages to standard error. 参考： https://github.com/golang/go/wiki/Modules https://blog.golang.org/modules2019 https://blog.golang.org/using-go-modules Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"introduction/package/dep-usage.html":{"url":"introduction/package/dep-usage.html","title":"dep的使用","keywords":"","body":"1. dep简介 dep是一个golang项目的包管理工具，一般只需要2-3个命令就可以将go依赖包自动下载并归档到vendor的目录中。dep官网参考：https://github.com/golang/dep 2. dep安装 go get -u github.com/golang/dep/cmd/dep 3. dep使用 #进入到项目目录 cd /home/gopath/src/demo #dep初始化，初始化配置文件Gopkg.toml dep init #dep加载依赖包，自动归档到vendor目录 dep ensure # 最终会生成vendor目录，Gopkg.toml和Gopkg.lock的文件 4. dep的配置文件 Gopkg.toml记录依赖包列表。 # Gopkg.toml example # # Refer to https://golang.github.io/dep/docs/Gopkg.toml.html # for detailed Gopkg.toml documentation. # # required = [\"github.com/user/thing/cmd/thing\"] # ignored = [\"github.com/user/project/pkgX\", \"bitbucket.org/user/project/pkgA/pkgY\"] # # [[constraint]] # name = \"github.com/user/project\" # version = \"1.0.0\" # # [[constraint]] # name = \"github.com/user/project2\" # branch = \"dev\" # source = \"github.com/myfork/project2\" # # [[override]] # name = \"github.com/x/y\" # version = \"2.4.0\" # # [prune] # non-go = false # go-tests = true # unused-packages = true ignored = [\"demo\"] [[constraint]] name = \"github.com/BurntSushi/toml\" version = \"0.3.0\" [prune] go-tests = true unused-packages = true 5. dep-help 更多dep的命令帮助参考dep。 $ dep Dep is a tool for managing dependencies for Go projects Usage: \"dep [command]\" Commands: init Set up a new Go project, or migrate an existing one status Report the status of the project's dependencies ensure Ensure a dependency is safely vendored in the project prune Pruning is now performed automatically by dep ensure. version Show the dep version information Examples: dep init set up a new project dep ensure install the project's dependencies dep ensure -update update the locked versions of all dependencies dep ensure -add github.com/pkg/errors add a dependency to the project Use \"dep help [command]\" for more information about a command. Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"introduction/package/govendor-usage.html":{"url":"introduction/package/govendor-usage.html","title":"govendor的使用","keywords":"","body":"1. govendor简介 golang工程的依赖包经常使用go get 的方式来获取，例如：go get github.com/kardianos/govendor ，会将依赖包下载到GOPATH的路径下。 常用的依赖包管理工具有godep，govendor等，在Golang1.5之后，Go提供了 GO15VENDOREXPERIMENT 环境变量，用于将go build时的应用路径搜索调整成为 当前项目目录/vendor 目录方式。通过这种形式，我们可以实现类似于 godep 方式的项目依赖管理。 2. 安装与使用 2.1. 安装 go get -u -v github.com/kardianos/govendor 2.2. 使用 #进入到项目目录 cd /home/gopath/src/mytool #初始化vendor目录 govendor init #查看vendor目录 [root@CC54425A mytool]# ls commands main.go vendor mytool_test.sh #进入vendor目录 cd vendor #将GOPATH中本工程使用到的依赖包自动移动到vendor目录中 #说明：如果本地GOPATH没有依赖包，先go get相应的依赖包 govendor add +external #通过设置环境变量 GO15VENDOREXPERIMENT=1 使用vendor文件夹构建文件。 #可以选择 export GO15VENDOREXPERIMENT=1 或 GO15VENDOREXPERIMENT=1 go build 执行编译 export GO15VENDOREXPERIMENT=1 2.3. 说明 govendor只是用来管理项目的依赖包，如果GOPATH中本身没有项目的依赖包，则需要通过go get先下载到GOPATH中，再通过govendor add +external 拷贝到vendor目录中。 3. govendor的配置文件 vendor.json记录依赖包列表。 { \"comment\": \"\", \"ignore\": \"test\", \"package\": [ { \"checksumSHA1\": \"uGalSICR4r7354vvKuNnh7Y/R/4=\", \"path\": \"github.com/urfave/cli\", \"revision\": \"b99aa811b4c1dd84cc6bccb8499c82c72098085a\", \"revisionTime\": \"2017-08-04T09:34:15Z\" } ], \"rootPath\": \"mytool\" } 4. govendor使用命令 [root@CC54425A mytool]# govendor govendor (v1.0.8): record dependencies and copy into vendor folder -govendor-licenses Show govendor's licenses. -version Show govendor version -cpuprofile 'file' Writes a CPU profile to 'file' for debugging. -memprofile 'file' Writes a heap profile to 'file' for debugging. Sub-Commands init Create the \"vendor\" folder and the \"vendor.json\" file. list List and filter existing dependencies and packages. add Add packages from $GOPATH. update Update packages from $GOPATH. remove Remove packages from the vendor folder. status Lists any packages missing, out-of-date, or modified locally. fetch Add new or update vendor folder packages from remote repository. sync Pull packages into vendor folder from remote repository with revisions from vendor.json file. migrate Move packages from a legacy tool to the vendor folder with metadata. get Like \"go get\" but copies dependencies into a \"vendor\" folder. license List discovered licenses for the given status or import paths. shell Run a \"shell\" to make multiple sub-commands more efficient for large projects. go tool commands that are wrapped: \"+status\" package selection may be used with them fmt, build, install, clean, test, vet, generate, tool Status Types +local (l) packages in your project +external (e) referenced packages in GOPATH but not in current project +vendor (v) packages in the vendor folder +std (s) packages in the standard library +excluded (x) external packages explicitly excluded from vendoring +unused (u) packages in the vendor folder, but unused +missing (m) referenced packages but not found +program (p) package is a main package +outside +external +missing +all +all packages Status can be referenced by their initial letters. Package specifier [::][{/...|/^}][@[]] Ignoring files with build tags, or excluding packages from being vendored: The \"vendor.json\" file contains a string field named \"ignore\". It may contain a space separated list of build tags to ignore when listing and copying files. This list may also contain package prefixes (containing a \"/\", possibly as last character) to exclude when copying files in the vendor folder. If \"foo/\" appears in this field, then package \"foo\" and all its sub-packages (\"foo/bar\", …) will be excluded (but package \"bar/foo\" will not). By default the init command adds the \"test\" tag to the ignore list. If using go1.5, ensure GO15VENDOREXPERIMENT=1 is set. Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"introduction/package/glide-usage.html":{"url":"introduction/package/glide-usage.html","title":"glide的使用","keywords":"","body":"1. glide简介 glide是一个golang项目的包管理工具，非常方便快捷，一般只需要2-3个命令就可以将go依赖包自动下载并归档到vendor的目录中。 2. glide安装 go get github.com/Masterminds/glide 3. glide使用 #进入到项目目录 cd /home/gopath/src/demo #glide初始化，初始化配置文件glide.yaml glide init #glide加载依赖包，自动归档到vendor目录 glide up -v 4. glide的配置文件 glide.yaml记录依赖包列表。 package: demo import: - package: github.com/astaxie/beego version: v1.9.2 testImport: - package: github.com/smartystreets/goconvey version: 1.6.3 subpackages: - convey 5. glide-help 更多glide的命令帮助参考glide —help。 ➜ demo glide --help NAME: glide - Vendor Package Management for your Go projects. Each project should have a 'glide.yaml' file in the project directory. Files look something like this: package: github.com/Masterminds/glide imports: - package: github.com/Masterminds/cookoo version: 1.1.0 - package: github.com/kylelemons/go-gypsy subpackages: - yaml For more details on the 'glide.yaml' files see the documentation at https://glide.sh/docs/glide.yaml USAGE: glide [global options] command [command options] [arguments...] VERSION: 0.13.2-dev COMMANDS: create, init Initialize a new project, creating a glide.yaml file config-wizard, cw Wizard that makes optional suggestions to improve config in a glide.yaml file. get Install one or more packages into `vendor/` and add dependency to glide.yaml. remove, rm Remove a package from the glide.yaml file, and regenerate the lock file. import Import files from other dependency management systems. name Print the name of this project. novendor, nv List all non-vendor paths in a directory. rebuild Rebuild ('go build') the dependencies install, i Install a project's dependencies update, up Update a project's dependencies tree (Deprecated) Tree prints the dependencies of this project as a tree. list List prints all dependencies that the present code references. info Info prints information about this project cache-clear, cc Clears the Glide cache. about Learn about Glide mirror Manage mirrors help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --yaml value, -y value Set a YAML configuration file. (default: \"glide.yaml\") --quiet, -q Quiet (no info or debug messages) --debug Print debug verbose informational messages --home value The location of Glide files (default: \"/Users/meitu/.glide\") [$GLIDE_HOME] --tmp value The temp directory to use. Defaults to systems temp [$GLIDE_TMP] --no-color Turn off colored output for log messages --help, -h show help --version, -v print the version Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"basis/var-const.html":{"url":"basis/var-const.html","title":"变量与常量","keywords":"","body":"1.变量 1.1变量声明 //1、单变量声明,类型放在变量名之后，可以为任意类型 var 变量名 类型 var v1,v2,v3 string //多变量同类型声明 //2、多变量声明 var { v1 int v2 []int } 1.2变量初始化 //1、使用关键字var，声明变量类型并赋值 var v1 int=10 //2、使用关键字var，直接对变量赋值，go可以自动推导出变量类型 var v2=10 //3、直接使用“：=”对变量赋值，不使用var，两者同时使用会语法冲突，推荐使用 v3:=10 1.3变量赋值 //1、声明后再变量赋值 var v int v=10 //2、多重赋值，经常使用在函数的多返回值中，err,v=func(arg) i，j=j,i //两者互换，并不需要引入中间变量 1.4匿名变量 //Go中所有声明后的变量都需要调用到，当出现函数多返回值，并且部分返回值不需要使用时，可以使用匿名变量丢弃该返回值 func GetName()(firstName,lastName,nickName string){ return \"May\",\"Chan\",\"Make\" } _,_,nickName:=GetName() //使用匿名变量丢弃部分返回值 2.常量 ​ Go语言中，常量是编译时期就已知且不可变的值，常量可以是数值类型（整型、浮点型、复数类型）、布尔类型、字符串类型。 2.1字面常量 //字面常量(literal)指程序中硬编码的常量 3.14 “foo” true 2.2常量定义 //1、可以限定常量类型，但非必需 const Pi float64 = 3.14 //2、无类型常量和字面常量一样 const zero=0.0 //3、多常量赋值 const( size int64=1024 eof=-1 ) //4、常量的多重赋值，类似变量的多重赋值 const u,v float32=0,3 const a,b,c=3,4,\"foo\" //无类型常量的多重赋值 //5、常量赋值是编译期行为，可以赋值为一个编译期运算的常量表达式 const mask=1 2.3预定义常量 //预定义常量：true、false、iota //iota：可修改常量，在每次const出现时被重置为0，在下一个const出现前，每出现一次iota，其代表的值自动增1。 const( //iota重置为0 c0=iota //c0==0 c1=iota //c1==1 c2=iota //c2==2 ) //两个const赋值语句一样可以省略后一个 const( //iota重置为0 c0=iota //c0==0 c1 //c1==1 c2 //c2==2 ) 2.4枚举 枚举指一系列相关常量。 const( Sunday=iota //Sunday==0,以此类推 Monday Tuesday Wednesday Thursday Friday Saturday //大写字母开头表示包外可见 numberOfDays //小写字母开头表示包内私有 ) Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 17:28:32 "},"basis/data-types.html":{"url":"basis/data-types.html","title":"数据类型","keywords":"","body":"类型 1. 基础类型 1.1. 布尔类型 //布尔类型的关键字为bool,值为true或false，不可写为0或1 var v1 bool v1=true //接受表达式判断赋值，不支持自动或强制类型转换 v2:=(1==2) 1.2. 整型 //1、类型表示 //int和int32为不同类型，不会自动类型转换需要强制类型转换 //强制类型转换需注意精度损失（浮点数→整数），值溢出（大范围→小范围） var v2 int32 v1:=64 v2=int32(v1) //2、数值运算,支持“+,-,*,/和%” 5%3 //求余 //3、比较运算,“,==,>=, 图片 - 这里写图片描述 1.3. 浮点型 //1、浮点型分为float32(类似C中的float)，float64(类似C中的double) var f1 float32 f1=12 //不加小数点，被推导为整型 f2:=12.0 //加小数点，被推导为float64 f1=float32(f2) //需要执行强制转换 //2、浮点数的比较 //浮点数不是精确的表达方式，不能直接使用“==”来判断是否相等，可以借用math的包math.Fdim 1.4. 复数类型 //1、复数的表示 var v1 complex64 v1=3.2+12i //v1 v2 v3 表示为同一个数 v2:=3.2+12i v3:=complex(3.2,12) //2、实部与虚部 //z=complex(x,y),通过内置函数实部x=real(z),虚部y=imag(z) 1.5. 字符串 //声明与赋值 var str string str=\"hello world\" 图片 - 这里写图片描述 1.6. 字符类型 //1、byte，即uint8的别名 //2、rune，即Unicode 1.7. 错误类型（error） 2. 复合类型 2.1. 数组(array) 数组表示同一类型数据，数组长度定义后就不可更改，长度是数组内的一个内置常量，可通过len()来获取。 //1、创建数组 var array1 [5]int //声明：var 变量名 类型 var array2 [5]int=[5]int{1,2,3,4,5} //初始化 array3：=[5]int{1,2,3,4,5} //直接用“：=”赋值 [3][5]int //二维数组 [3]*float //指针数组 //2、元素访问 for i,v:=range array{ //第一个返回值为数组下标，第二个为元素的值 } //3、值类型 //数组在Go中作为一个值类型，值类型在赋值和函数参数传递时，只复制副本，因此在函数体中并不能改变数组的内容，需用指针来改变数组的值。 2.2. 切片(slice) ​ 数组在定义了长度后无法改变，且作为值类型在传递时产生副本，并不能改变数组元素的值。因此切片的功能弥补了这个不足，切片类似指向数组的一个指针。可以抽象为三个变量：指向数组的指针；切片中元素的个数(len函数)；已分配的存储空间(cap函数)。 //1、创建切片 //a)基于数组创建 var myArray [5]int=[5]{1,2,3,4,5} var mySlice []int=myArray[first:last] slice1=myArray[:] //基于数组所有元素创建 slice2=myArray[:3] //基于前三个元素创建 slice3=myArray[3:] //基于第3个元素开始后的所有元素创建 //b)直接创建 slice1:=make([]int,5) //元素初始值为0，初始个数为5 slice2:=make([]int,5,10) //元素初始值为0，初始个数为5，预留个数为10 slice3:=[]int{1,2,3,4,5} //初始化赋值 //c)基于切片创建 oldSlice:=[]int{1,2,3,4,5} newSlice:=oldSlice[:3] //基于切片创建，不能超过原切片的存储空间(cap函数的值) //2、元素遍历 for i,v:=range slice{ //与数组的方式一致，使用range来遍历 //第一个返回值(i)为索引，第二个为元素的值(v) } //3、动态增减元素 //切片分存储空间(cap)和元素个数(len)，当存储空间小于实际的元素个数，会重新分配一块原空间2倍的内存块，并将原数据复制到该内存块中，合理的分配存储空间可以以空间换时间，降低系统开销。 //添加元素 newSlice:=append(oldSlice,1,2,3) //直接将元素加进去，若存储空间不够会按上述方式扩容。 newSlice1:=append(oldSlice1,oldSlice2...) //将oldSlice2的元素打散后加到oldSlice1中，三个点不可省略。 //4、内容复制 //copy()函数可以复制切片，如果切片大小不一样，按较小的切片元素个数进行复制 slice1:=[]int{1,2,3,4,5} slice2:=[]int{6,7,8} copy(slice2,slice1) //只会复制slice1的前三个元素到slice2中 copy(slice1,slice1) //只会复制slice2的三个元素到slice1中的前三个位置 2.3. 键值对(map) map是一堆键值对的未排序集合。 //1、先声明后创建再赋值 var map1 map[键类型] 值类型 //创建 map1=make(map[键类型] 值类型) map1=make(map[键类型] 值类型 存储空间) //赋值 map1[key]=value // 直接创建 m2 := make(map[string]string) // 然后赋值 m2[\"a\"] = \"aa\" m2[\"b\"] = \"bb\" // 初始化 + 赋值一体化 m3 := map[string]string{ \"a\": \"aa\", \"b\": \"bb\", } //2、元素删除 //delete()函数删除对应key的键值对，如果key不存在，不会报错；如果value为nil，则会抛出异常(panic)。 delete(map1,key) //3、元素查找 value,ok:=myMap[key] if ok{//如果找到 //处理找到的value值 } //遍历 for key,value:=range myMap{ //处理key或value } map可以用来判断一个值是否在切片或数组中。 // 判断某个类型（假如为myType）的值是否在切片或数组（假如为myList）中 // 构造一个map,key的类型为myType,value为bool型 myMap := make(map[myType]bool) myList := []myType{value1, value2} // 将切片中的值存为map中的key（因为key不能重复）,map的value都为true for _, value := range myList { myMap[value] = true } // 判断valueX是否在myList中，即判断其是否在myMap的key中 if _, ok := myMap[valueX]; ok { // 如果valueX 在myList中，执行后续操作 } 2.4. 指针(pointer) 具体参考Go语言指针详解 2.5. 结构体(struct) 具体参考Go面向对象编程之结构体 2.6. 接口(interface) 具体参考Go面向对象编程之接口 2.7. 通道(chan) 具体参考Go并发编程之channel Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 19:28:13 "},"basis/control-structures.html":{"url":"basis/control-structures.html","title":"流程语句","keywords":"","body":"流程语句 1. 条件语句 //在if之后条件语句之前可以添加变量初始化语句，用;号隔离 if { //条件语句不需要用括号括起来，花括号必须存在 //语句体 }else{ //语句体 } //在有返回值的函数中，不允许将最后的return语句放在if...else...的结构中，否则会编译失败 //例如以下为错误范例 func example(x int) int{ if x==0{ return 5 }else{ return x //最后的return语句放在if-else结构中，所以编译失败 } } 2. 选择语句 //1、根据条件不同，对应不同的执行体 switch i{ case 0: fmt.Printf(\"0\") case 1: //满足条件就会退出，只有添加fallthrough才会继续执行下一个case语句 fmt.Prinntf(\"1\") case 2,3,1: //单个case可以出现多个选项 fmt.Printf(\"2,3,1\") default: //当都不满足以上条件时，执行default语句 fmt.Printf(\"Default\") } //2、该模式等价于多个if-else的功能 switch { case : 语句体1 case : 语句体2 } 3. 循环语句 //1、Go只支持for关键字，不支持while，do-while结构 for i,j:=0,1;i 100{ break //满足条件跳出循环 } } //3、支持continue和break，break可以指定中断哪个循环，break JLoop(标签) for j:=0;j5{ break JLoop //终止JLoop标签处的外层循环 } fmt.Println(i) } JLoop: //标签处 ... 4. 跳转语句 //关键字goto支持跳转 func myfunc(){ i:=0 HERE: //定义标签处 fmt.Println(i) i++ if i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 17:33:58 "},"basis/functions.html":{"url":"basis/functions.html","title":"函数与闭包","keywords":"","body":"函数 1. 函数定义与调用 //1、函数组成：关键字func ,函数名，参数列表，返回值，函数体，返回语句 //先名称后类型 func 函数名(参数列表)(返回值列表){ //参数列表和返回值列表以变量声明的形式，如果单返回值可以直接加类型 函数体 return //返回语句 } //例子 func Add(a,b int)(ret int,err error){ //函数体 return //return语句 } //2、函数调用 //先导入函数所在的包，直接调用函数 import \"mymath\" sum,err:=mymath.Add(1,2) //多返回值和错误处理机制 //可见性，包括函数、类型、变量 //本包内可见(private)：小写字母开头 //包外可见(public)：大写字母开头 2. 不定参数 //1、不定参数的类型 func myfunc(args ...int){ //...type不定参数的类型，必须是最后一个参数，本质是切片 for _,arg:=range args{ fmt.Println(arg) } } //函数调用,传参可以选择多个，个数不定 myfunc(1,2,3) myfunc(1,2,3,4,5) //2、不定参数的传递，假如有个变参函数myfunc2(args ...int) func myfunc1(args ...int){ //按原样传递 myfunc2(args...) //传递切片 myfunc2(args[1:]...) } //3、任意类型的不定参数，使用interface{}作为指定类型 func Printf(format string,args ...interface{}){ //此为标准库中fmt.Printf()函数的原型 //函数体 } 3. 多返回值 //多返回值 func (file *File) Read(b []byte) (n int,err error) //使用下划线\"_\"来丢弃返回值 n,_:=f.Read(buf) 4. 匿名函数 匿名函数：不带函数名的函数，可以像变量一样被传递。 func(a,b int,z float32) bool{ //没有函数名 return a*b 5. 闭包 5.1. 闭包的概念 闭包是可以包含自由变量（未绑定到特定的对象）的代码块，这些变量不在代码块内或全局上下文中定义，而在定义代码块的环境中定义。要执行的代码块为自由变量提供绑定的计算环境（作用域）。 5.2. 闭包的价值 闭包的价值在于可以作为一个变量对象来进行传递和返回。即可以把函数本身看作是一个变量。 5.3. Go中的闭包 Go闭包是指引用了函数外的变量的一种函数，这样该函数就被绑定在某个变量上，只要闭包还被使用则引用的变量会一直存在。 Go的匿名函数是一个闭包，Go闭包常用在go和defer关键字中。 5.4. 闭包的坑 在for range中goroutine的方式使用闭包，如果没有给匿名函数传入一个变量，或新建一个变量存储迭代的变量，那么goroutine执行的结果会是最后一个迭代变量的结果，而不是每个迭代变量的结果。这是因为如果没有通过一个变量来拷贝迭代变量，那么闭包因为绑定了变量，当每个groutine运行时，迭代变量可能被更改。 示例如下： // false, print 3 3 3 values := []int{1,2,3} for _, val := range values { go func() { fmt.Println(val) }() } // true, print 1 2 3 for _, val := range values { go func(val interface{}) { fmt.Println(val) }(val) } 5.5 闭包的示例 closure.go package main import ( \"fmt\" ) func main() { var j int = 5 a := func() func() { var i int = 10 return func() { fmt.Printf(\"i, j: %d, %d\\n\", i, j) } }() a() j *= 2 a() } 5.6 闭包的参考链接 https://tour.golang.org/moretypes/25 https://golang.org/doc/faq#closures_and_goroutines https://github.com/golang/go/wiki/CommonMistakes 参考： 《Go语言编程》 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"basis/errors.html":{"url":"basis/errors.html","title":"错误处理","keywords":"","body":"错误处理 1. error接口 //定义error接口 type error interface{ Error() string } //调用error接口 func Foo(param int) (n int,err error){ //... } n,err:=Foo(0) if err!=nil{ //错误处理 }else{ //使用返回值 } 2. defer[延迟函数] 语法： defer function_name() 1）defer在声明时不会执行，而是推迟执行，在return执行前，倒序执行defer[先进后出]，一般用于释放资源，清理数据，记录日志，异常处理等。 2）defer有一个特性：即使函数抛出异常，defer仍会被执行，这样不会出现程序错误导致资源不被释放，或者因为第三方包的异常导致程序崩溃。 3）一般用于打开文件后释放资源的操作，比如打开一个文件，最后总是要关闭的。而在打开和关闭之间，会有诸多的处理，可能会有诸多的if-else、根据不同的情况需要提前返回 f, = os.open(filename) defer f.close() do_something() if (condition_a) {return} do_something_again() if (condition_b) {return} do_further_things() 4）defer示例 package main import \"fmt\" func deferTest(number int) int { defer func() { number++ fmt.Println(\"three:\", number) }() defer func() { number++ fmt.Println(\"two:\", number) }() defer func() { number++ fmt.Println(\"one:\", number) }() return number } func main() { fmt.Println(\"函数返回值：\", deferTest(0)) } /* one: 1 two: 2 three: 3 函数返回值： 0 */ 3. panic()和recover() Go中使用内置函数panic()和recover()来处理程序中的错误。 func panic(interface{}) func recover() interface{} 3.1. panic() 当函数执行触发了panic()函数时，如果没有使用到defer关键字，函数执行流程会被立即终止；如果使用了defer关键字，则会逐层执行defer语句，直到所有的函数被终止。 错误信息，包括panic函数传入的参数，将会被报告出来。 示例如下： panic(404) panic(\"network broken\") panic(Error(\"file not exists\")) 3.2. recover() recover()函数用于终止错误处理流程。一般使用在defer关键字后以有效截取错误处理流程。如果没有在发生异常的goroutine中明确调用恢复过程（使用recover关键字） ，会导致该goroutine所属的进程打印异常信息后直接退出。 示例如下： defer func() { if r := recover(); r != nil { log.Printf(\"Runtime error caught: %v\", r) } }() foo() 无论foo()中是否触发了错误处理流程，该匿名defer函数都将在函数退出时得到执行。假如foo()中触发了错误处理流程， recover()函数执行将使得该错误处理过程终止。如果错误处理流程被触发时，程序传给panic函数的参数不为nil，则该函数还会打印详细的错误信息。 参考： 《Go语言编程》 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"oop/oop.html":{"url":"oop/oop.html","title":"概述","keywords":"","body":"面向对象编程 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）[方法的重写，子类不同于父类的特性]／泛化（generalization）[共性，子类都拥有父类的特性]，通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。 面对对象思想 面向对象思想是对现实世界事物的抽象，系统中一切事物皆为对象；对象是属性及其操作的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息的序列。 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"oop/struct-method.html":{"url":"oop/struct-method.html","title":"类与方法","keywords":"","body":"1. 类型系统[类的声明] 类型系统： 一组基本类型构成的“基本类型集合”； “基本类型集合”上定义的一系列组合、运算、转换方法。 类型系统包括基础类型（byte、int、bool、float等）；复合类型（数组、结构体、指针等）；可以指向任何对象的类型（Any类型，类似Java的Object类型）；值语义和引用语义；面向对象类型；接口。Go大多数类型为值语义，可以给任何类型添加方法（包括内置类型，不包括指针类型）。Any类型是空接口即interface{}。 2. 结构体 结构体[类属性的声明] struct的功能类似Java的class，可实现嵌套组合(类似继承的功能) struct实际上就是一种复合类型，只是对类中的属性进行定义赋值，并没有对方法进行定义，方法可以随时定义绑定到该类的对象上，更具灵活性。可利用嵌套组合来实现类似继承的功能避免代码重复。 type Rect struct{ //定义矩形类 x,y float64 //类型只包含属性，并没有方法 width,height float64 } func (r *Rect) Area() float64{ //为Rect类型绑定Area的方法，*Rect为指针引用可以修改传入参数的值 return r.width*r.height //方法归属于类型，不归属于具体的对象，声明该类型的对象即可调用该类型的方法 } 3. 方法 1、为类型添加方法[类方法声明]，方法即为有接收者的函数 func (对象名 对象类型) 函数名(参数列表) (返回值列表) 可随时为某个对象添加方法即为某个方法添加归属对象（receiver），以方法为中心 在Go语言中没有隐藏的this指针，即显示传递，形参即为this，例如以下的形参为a。 type Integer int func (a Integer) Less(b Integer) bool{ //表示a这个对象定义了Less这个方法，a可以为任意类型 return a 4. 值语义和引用语义 值类型：b的修改并不会影响a的值 引用类型：b的修改会影响a的值 Go大多类型为值语义，包括基本类型：byte，int，string等；复合类型：数组，结构体(struct)，指针等 //2、值语义和引用语义 b=a b.Modify() //值类型 var a=[3]int{1,2,3} b:=a b[1]++ fmt.Println(a,b) //a=[1,2,3] b=[1,3,3] //引用类型 a:=[3]int{1,2,3} b:=&a //b指向a,即为a的地址，对b指向的值改变实际上就是对a的改变（数组本身就是一种地址指向） b[1]++ fmt.Println(a,*b) //a=[1,3,3] b=[1,3,3] //*b,取地址指向的值 5. 初始化[实例化对象] 数据初始化的内建函数new()与make()，二者都是用来分配空间。区别如下: 5.1. new() func new(Type) *Type 内置函数 new 分配空间。传递给new 函数的是一个类型，不是一个值。返回值是指向这个新分配的零值的指针 5.2. make() func make(Type, size IntegerType) Type 内建函数 make 分配并且初始化 一个 slice, 或者 map 或者 chan 对象。 并且只能是这三种对象。 和 new 一样，第一个参数是 类型，不是一个值。 但是make 的返回值就是这个类型（即使一个引用类型），而不是指针。 具体的返回值，依赖具体传入的类型。 5.3. 示例 //创建实例 rect1:=new(Rect) //new一个对象 rect2:=&Rect{} //为赋值默认值，bool默认值为false，int默认为零值0，string默认为空字符串 rect3:=&Rect{0,0,100,200} //取地址并赋值,按声明的变量顺序依次赋值 rect4:=&Rect{width:100,height:200} //按变量名赋值不按顺序赋值 //构造函数：没有构造参数的概念，通常由全局的创建函数NewXXX来实现构造函数的功能 func NewRect(x,y,width,height float64) *Rect{ return &Rect{x,y,width,height} //利用指针来改变传入参数的值达到类似构造参数的效果 } //方法的重载,Go不支持方法的重载（函数同名，参数不同） //v …interface{}表示参数不定的意思，其中v是slice类型，及声明不定参数，可以传入任意参数，实现类似方法的重载 func (poem *Poem) recite(v ...interface{}) { fmt.Println(v) } 6. 匿名组合[继承] ​ 组合，即方法代理，例如A包含B，即A通过消息传递的形式代理了B的方法，而不需要重复写B的方法。 ​ 继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。继承主要为了代码复用，继承也可以扩展已存在的代码模块（类）。 ​ 严格来讲，继承是“a kind of ”，即子类是父类的一种，例如student是person的一种；组合是“a part of”，即父类是子类中的一部分，例如眼睛是头部的一部分。 //1、匿名组合的方式实现了类似Java继承的功能，可以实现多继承 type Base struct{ Name string } func (base *Base) Foo(){...} //Base的Foo()方法 func (base *Base) Bar(){...} //Base的Bar()方法 type Foo struct{ Base //通过组合的方式声明了基类，即继承了基类 ... } func (foo *Foo) Bar(){ foo.Base.Bar() //并改写了基类的方法，该方法实现时先调用基类的Bar()方法 ... //如果没有改写即为继承，调用foo.Foo()和调用foo.Base.Foo()的作用的一样的 } //修改内存布局 type Foo struct{ ... //其他成员信息 Base } //以指针方式组合 type Foo struct{ *Base //以指针方式派生，创建Foo实例时，需要外部提供一个Base类实例的指针 ... } //名字冲突问题,组合内外如果出现名字重复问题，只会访问到最外层，内层会被隐藏，不会报错，即类似java中方法覆盖/重写。 type X struct{ Name string } type Y struct{ X //Y.X.Name会被隐藏，内层会被隐藏 Name string //只会访问到Y.Name，只会调用外层属性 } 7. 可见性[封装] 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 封装的本质或目的其实程序对信息(数据)的控制力。封装分为两部分：该隐藏的隐藏，该暴露的暴露。封装可以隐藏实现细节，使得代码模块化。 Go中用大写字母开头来表示public，可以包外访问；小写字母开头来表示private，只能包内访问；访问性是包级别非类型级别,如果可访问性是类型一致的，可以加friend关键字表示朋友关系可互相访问彼此的私有成员(属性和方法) type Rect struct{ X,Y float64 Width,Height float64 //字母大写开头表示该属性可以由包外访问到 } func (r *Rect) area() float64{ //字母小写开头表示该方法只能包内调用 return r.Width*r.Height } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 17:56:56 "},"oop/interface/interface.html":{"url":"oop/interface/interface.html","title":"接口概述","keywords":"","body":"1. 接口[多态] ​多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 简而言之，就是允许将子类类型的指针赋值给父类类型的指针。 即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态分为编译时多态（静态多态）和运行时多态（动态多态），编译时多态一般通过方法重载实现，运行时多态一般通过方法重写实现。 1.1 接口概念 接口类型可以看作是类型系统中一种特殊的类型，而实例就是实现了该接口的具体结构体类型。 接口类型与实现了该接口的结构体对象之间的关系好比变量类型与变量之间的关系。 ​ 接口即一组方法定义的集合，定义了对象的一组行为，由具体的类型实例实现具体的方法。换句话说，一个接口就是定义（规范或约束），而方法就是实现，接口的作用应该是将定义与实现分离，降低耦合度。习惯用“er”结尾来命名，例如“Reader”。接口与对象的关系是多对多，即一个对象可以实现多个接口，一个接口也可以被多个对象实现。 ​ 接口是Go语言整个类型系统的基石，其他语言的接口是不同组件之间的契约的存在，对契约的实现是强制性的，必须显式声明实现了该接口，这类接口称之为“侵入式接口”。而Go语言的接口是隐式存在，只要实现了该接口的所有函数则代表已经实现了该接口，并不需要显式的接口声明。 接口的比喻 ​ 你的电脑上只有一个USB接口。这个USB接口可以接MP3，数码相机，摄像头，鼠标，键盘等。。。所有的上述硬件都可以公用这个接口，有很好的扩展性，该USB接口定义了一种规范，只要实现了该规范，就可以将不同的设备接入电脑，而设备的改变并不会对电脑本身有什么影响（低耦合）。 面向接口编程 ​ 接口表示调用者和设计者的一种约定，在多人合作开发同一个项目时，事先定义好相互调用的接口可以大大提高开发的效率。接口是用类来实现的，实现接口的类必须严格按照接口的声明来实现接口提供的所有功能。有了接口，就可以在不影响现有接口声明的情况下，修改接口的内部实现，从而使兼容性问题最小化。 ​ 面向接口编程可以分为三方面：制定者（或者叫协调者），实现者（或者叫生产者），调用者（或者叫消费者）。 ​ 当其他设计者调用了接口后，就不能再随意更改接口的定义，否则项目开发者事先的约定就失去了意义。但是可以在类中修改相应的代码，完成需要改动的内容。 1.2 非侵入式接口 非侵入式接口：一个类只需要实现了接口要求的所有函数就表示实现了该接口，并不需要显式声明 type File struct{ //类的属性 } //File类的方法 func (f *File) Read(buf []byte) (n int,err error) func (f *File) Write(buf []byte) (n int,err error) func (f *File) Seek(off int64,whence int) (pos int64,err error) func (f *File) Close() error //接口1：IFile type IFile interface{ Read(buf []byte) (n int,err error) Write(buf []byte) (n int,err error) Seek(off int64,whence int) (pos int64,err error) Close() error } //接口2：IReader type IReader interface{ Read(buf []byte) (n int,err error) } //接口赋值,File类实现了IFile和IReader接口，即接口所包含的所有方法 var file1 IFile = new(File) var file2 IReader = new(File) 1.3 接口赋值 只要类实现了该接口的所有方法，即可将该类赋值给这个接口，接口主要用于多态化方法。即对接口定义的方法，不同的实现方式。 接口赋值： 1）将对象实例赋值给接口 type IUSB interface{ //定义IUSB的接口方法 } //方法定义在类外，绑定该类，以下为方便，备注写在类中 type MP3 struct{ //实现IUSB的接口，具体实现方式是MP3的方法 } type Mouse struct{ //实现IUSB的接口，具体实现方式是Mouse的方法 } //接口赋值给具体的对象实例MP3 var usb IUSB =new(MP3) usb.Connect() usb.Close() //接口赋值给具体的对象实例Mouse var usb IUSB =new(Mouse) usb.Connect() usb.Close() 2）将接口赋值给另一个接口 只要两个接口拥有相同的方法列表（与次序无关），即是两个相同的接口，可以相互赋值 接口赋值只需要接口A的方法列表是接口B的子集（即假设接口A中定义的所有方法，都在接口B中有定义），那么B接口的实例可以赋值给A的对象。反之不成立，即子接口B包含了父接口A，因此可以将子接口的实例赋值给父接口。 即子接口实例实现了子接口的所有方法，而父接口的方法列表是子接口的子集，则子接口实例自然实现了父接口的所有方法，因此可以将子接口实例赋值给父接口。 type Writer interface{ //父接口 Write(buf []byte) (n int,err error) } type ReadWriter interface{ //子接口 Read(buf []byte) (n int,err error) Write(buf []byte) (n int,err error) } var file1 ReadWriter=new(File) //子接口实例 var file2 Writer=file1 //子接口实例赋值给父接口 1.4 接口查询 若要在 switch 外判断一个接口类型是否实现了某个接口，可以使用“逗号 ok ”。 value, ok := Interfacevariable.(implementType) 其中 Interfacevariable 是接口变量（接口值），implementType 为实现此接口的类型，value 返回接口变量实际类型变量的值，如果该类型实现了此接口返回 true。 //判断file1接口指向的对象实例是否是File类型 var file1 Writer=... if file5,ok:=file1.(File);ok{ ... } 1.5 接口类型查询 在 Go 中，要判断传递给接口值的变量类型，可以在使用 type switch 得到。(type)只能在 switch 中使用。 // 另一个实现了 I 接口的 R 类型 type R struct { i int } func (p *R) Get() int { return p.i } func (p *R) Put(v int) { p.i = v } func f(p I) { switch t := p.(type) { // 判断传递给 p 的实际类型 case *S: // 指向 S 的指针类型 case *R: // 指向 R 的指针类型 case S: // S 类型 case R: // R 类型 default: //实现了 I 接口的其他类型 } } 1.6 接口组合 //接口组合类似类型组合，只不过只包含方法，不包含成员变量 type ReadWriter interface{ //接口组合，避免代码重复 Reader //接口Reader Writer //接口Writer } 1.7 Any类型[空接口] 每种类型都能匹配到空接口：interface{}。空接口类型对方法没有任何约束（因为没有方法），它能包含任意类型，也可以实现到其他接口类型的转换。如果传递给该接口的类型变量实现了转换后的接口则可以正常运行，否则出现运行时错误。 //interface{}即为可以指向任何对象的Any类型，类似Java中的Object类 var v1 interface{}=struct{X int}{1} var v2 interface{}=\"abc\" func DoSomething(v interface{}) { //该函数可以接收任何类型的参数，因为任何类型都实现了空接口 // ... } 1.8 接口的代码示例 //接口animal type Animal interface { Speak() string } //Dog类实现animal接口 type Dog struct { } func (d Dog) Speak() string { return \"Woof!\" } //Cat类实现animal接口 type Cat struct { } func (c Cat) Speak() string { return \"Meow!\" } //Llama实现animal接口 type Llama struct { } func (l Llama) Speak() string { return \"?????\" } //JavaProgrammer实现animal接口 type JavaProgrammer struct { } func (j JavaProgrammer) Speak() string { return \"Design patterns!\" } //主函数 func main() { animals := []Animal{Dog{}, Cat{}, Llama{}, JavaProgrammer{}} //利用接口实现多态 for _, animal := range animals { fmt.Println(animal.Speak()) //打印不同实现该接口的类的方法返回值 } } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 17:39:02 "},"oop/interface/client-go-interface.html":{"url":"oop/interface/client-go-interface.html","title":"client-go中接口","keywords":"","body":"2. client-go中接口的使用分析 以下以k8s.io/client-go/kubernetes/typed/core/v1/pod.go的pod对象做分析。 2.1 接口设计与定义 2.1.1 接口组合 // PodsGetter has a method to return a PodInterface. // A group's client should implement this interface. type PodsGetter interface { Pods(namespace string) PodInterface } 2.1.2 接口定义 // PodInterface has methods to work with Pod resources. type PodInterface interface { Create(*v1.Pod) (*v1.Pod, error) Update(*v1.Pod) (*v1.Pod, error) UpdateStatus(*v1.Pod) (*v1.Pod, error) Delete(name string, options *meta_v1.DeleteOptions) error DeleteCollection(options *meta_v1.DeleteOptions, listOptions meta_v1.ListOptions) error Get(name string, options meta_v1.GetOptions) (*v1.Pod, error) List(opts meta_v1.ListOptions) (*v1.PodList, error) Watch(opts meta_v1.ListOptions) (watch.Interface, error) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1.Pod, err error) PodExpansion } PodInterface接口定义了pod对象所使用的方法，一般为增删改查等。其他kubernetes资源对象的接口定义类似，区别在于入参和出参与对象相关。例如Create(*v1.Pod) (*v1.Pod, error)方法定义的入参出参为*v1.Pod。如果要实现该接口，即实现该接口的所有方法。 2.2 接口的实现 2.2.1 结构体的定义 // pods implements PodInterface type pods struct { client rest.Interface ns string } 2.2.2 new函数[构造函数] // newPods returns a Pods func newPods(c *CoreV1Client, namespace string) *pods { return &pods{ client: c.RESTClient(), ns: namespace, } } 2.2.3 方法的实现 Get // Get takes name of the pod, and returns the corresponding pod object, and an error if there is any. func (c *pods) Get(name string, options meta_v1.GetOptions) (result *v1.Pod, err error) { result = &v1.Pod{} err = c.client.Get(). Namespace(c.ns). Resource(\"pods\"). Name(name). VersionedParams(&options, scheme.ParameterCodec). Do(). Into(result) return } List // List takes label and field selectors, and returns the list of Pods that match those selectors. func (c *pods) List(opts meta_v1.ListOptions) (result *v1.PodList, err error) { result = &v1.PodList{} err = c.client.Get(). Namespace(c.ns). Resource(\"pods\"). VersionedParams(&opts, scheme.ParameterCodec). Do(). Into(result) return } Create // Create takes the representation of a pod and creates it. Returns the server's representation of the pod, and an error, if there is any. func (c *pods) Create(pod *v1.Pod) (result *v1.Pod, err error) { result = &v1.Pod{} err = c.client.Post(). Namespace(c.ns). Resource(\"pods\"). Body(pod). Do(). Into(result) return } Update // Update takes the representation of a pod and updates it. Returns the server's representation of the pod, and an error, if there is any. func (c *pods) Update(pod *v1.Pod) (result *v1.Pod, err error) { result = &v1.Pod{} err = c.client.Put(). Namespace(c.ns). Resource(\"pods\"). Name(pod.Name). Body(pod). Do(). Into(result) return } Delete // Delete takes name of the pod and deletes it. Returns an error if one occurs. func (c *pods) Delete(name string, options *meta_v1.DeleteOptions) error { return c.client.Delete(). Namespace(c.ns). Resource(\"pods\"). Name(name). Body(options). Do(). Error() } 2.3 接口的调用 示例： // 创建clientset实例 clientset, err := kubernetes.NewForConfig(config) // 具体的调用 pods, err := clientset.CoreV1().Pods(\"\").List(metav1.ListOptions{}) clientset实现了接口Interface，Interface是个接口组合，包含各个client的接口类型。例如CoreV1()方法对应的接口类型是CoreV1Interface。 以下是clientset的CoreV1()方法实现： // CoreV1 retrieves the CoreV1Client func (c *Clientset) CoreV1() corev1.CoreV1Interface { return c.coreV1 } 该方法可以理解为是一个构造函数。构造函数的返回值类型是一个接口类型CoreV1Interface，而return的返回值是实现了该接口类型的结构体对象c.coreV1。 接口类型是一种特殊的类型，接口类型与结构体对象之间的关系好比变量类型与变量之间的关系。其中的结构体对象必须实现了该接口类型的所有方法。 所以clientset的CoreV1()方法实现是返回一个CoreV1Client结构体对象。该结构体对象实现了CoreV1Interface接口，该接口也是一个接口组合。 type CoreV1Interface interface { RESTClient() rest.Interface ComponentStatusesGetter ConfigMapsGetter EndpointsGetter EventsGetter LimitRangesGetter NamespacesGetter NodesGetter PersistentVolumesGetter PersistentVolumeClaimsGetter PodsGetter PodTemplatesGetter ReplicationControllersGetter ResourceQuotasGetter SecretsGetter ServicesGetter ServiceAccountsGetter } 而实现的Pods()方法是其中的PodsGetter接口。 Pods()同CoreV1()一样是个构造函数，构造函数的返回值类型是PodInterface接口，返回值是实现了PodInterface接口的pods结构体对象。 func (c *CoreV1Client) Pods(namespace string) PodInterface { return newPods(c, namespace) } 而PodInterface接口定义参考接口定义，pods对象实现了PodInterface接口的方法，具体参考接口的实现。 最终调用了pods对象的List()方法。 pods, err := clientset.CoreV1().Pods(\"\").List(metav1.ListOptions{}) 即以上代码就是不断调用实现了某接口的结构体对象的构造函数，生成具体的结构体对象，再调用结构体对象的某个具体方法。 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 17:37:41 "},"oop/interface/common-interface.html":{"url":"oop/interface/common-interface.html","title":"通用接口设计","keywords":"","body":"3. 通用接口设计 3.1 接口定义 // ProjectManager manage life cycle of Deployment and Resources type PodInterface interface { Create(*v1.Pod) (*v1.Pod, error) Update(*v1.Pod) (*v1.Pod, error) UpdateStatus(*v1.Pod) (*v1.Pod, error) Delete(name string, options *meta_v1.DeleteOptions) error DeleteCollection(options *meta_v1.DeleteOptions, listOptions meta_v1.ListOptions) error Get(name string, options meta_v1.GetOptions) (*v1.Pod, error) List(opts meta_v1.ListOptions) (*v1.PodList, error) Watch(opts meta_v1.ListOptions) (watch.Interface, error) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1.Pod, err error) PodExpansion } 3.2 结构体定义 // pods implements PodInterface type pods struct { client rest.Interface ns string } 3.3 构造函数 // newPods returns a Pods func newPods(c *CoreV1Client, namespace string) *pods { return &pods{ client: c.RESTClient(), ns: namespace, } } 3.4 结构体实现 List() // List takes label and field selectors, and returns the list of Pods that match those selectors. func (c *pods) List(opts meta_v1.ListOptions) (result *v1.PodList, err error) { result = &v1.PodList{} err = c.client.Get(). Namespace(c.ns). Resource(\"pods\"). VersionedParams(&opts, scheme.ParameterCodec). Do(). Into(result) return } 3.5 接口调用 pods, err := clientset.CoreV1().Pods(\"\").List(metav1.ListOptions{}) 3.6 其他接口设计示例 type XxxManager interface { Create(args argsType) (*XxxStruct, error) Get(args argsType) (**XxxStruct, error) Update(args argsType) (*XxxStruct, error) Delete(name string, options *DeleleOptions) error } type XxxManagerImpl struct { Name string Namespace string kubeCli *kubernetes.Clientset } func NewXxxManagerImpl (namespace, name string, kubeCli *kubernetes.Clientset) XxxManager { return &XxxManagerImpl{ Name name, Namespace namespace, kubeCli: kubeCli, } } func (xm *XxxManagerImpl) Create(args argsType) (*XxxStruct, error) { //具体的方法实现 } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 17:38:50 "},"oop/pointer.html":{"url":"oop/pointer.html","title":"指针","keywords":"","body":"1. 指针的概念 概念 说明 变量 是一种占位符，用于引用计算机的内存地址。可理解为内存地址的标签 指针 表示内存地址，表示地址的指向。指针是一个指向另一个变量内存地址的值 & 取地址符，例如：{指针}:=&{变量} * 取值符，例如：{变量}:=*{指针} 2. 内存地址说明 2.1. 内存定义 计算机的内存 RAM 可以把它想象成一些有序的盒子，一个接一个的排成一排，每一个盒子或者单元格都被一个唯一的数字标记依次递增，这个数字就是该单元格的地址，也就是内存的地址。 硬件角度：内存是CPU沟通的桥梁，程序运行在内存中。 逻辑角度：内存是一块具备随机访问能力，支持读写操作，用来存放程序及程序运行中产生的数据的区域。 概念 比喻 内存 一层楼层 内存块 楼层中的一个房间 变量名 房间的标签，例如：总经理室 指针 房间的具体地址（门牌号），例如：总经理室地址是2楼201室 变量值 房间里的具体存储物 指针地址 指针的地址：存储指针内存块的地址 2.2. 内存单位和编址 2.2.1. 内存单位 单位 说明 位（bit） 计算机中最小的数据单位，每一位的状态只能是0或1 字节（Byte） 1Byte=8bit，是内存基本的计量单位 字 “字”由若干个字节构成，字的位数叫字长，不同档次的机器有不同的字长 KB 1KB=1024Byte，即1024个字节 MB 1MB=1024KB GB 1GB=1024MB 2.2.2. 内存编址 计算机中的内存按字节编址，每个地址的存储单元可以存放一个字节的数据，CPU通过内存地址获取指令和数据，并不关心这个地址所代表的空间在什么位置，内存地址和地址指向的空间共同构成了一个内存单元。 2.2.3. 内存地址 内存地址通常用16进制的数据表示，例如0x0ffc1。 3.变量与指针运算理解 编写一段程序，检索出值并存储在地址为 200 的一个块内存中，将其乘以 3，并将结果存储在地址为 201 的另一块内存中 3.1.本质 检索出内存地址为 200 的值，并将其存储在 CPU 中 将存储在 CPU 中的值乘以 3 将 CPU 中存储的结果，写入地址为 201 的内存块中 图片 - 什么是变量 3.2.基于变量的理解 获取变量 a 中存储的值，并将其存储在 CPU 中 将其乘以 3 将结果保存在变量 b 中 图片 - 什么是变量2 var a = 6 var b = a * 3 3.3.基于指针的理解 func main() { a := 200 b := &a *b++ fmt.Println(a) } 以上函数对a进行+1操作，具体理解如下： 1.a:=200 图片 - 什么是指针 2. b := &a 图片 - 什么是指针2 3. *b++ 图片 - 什么是指针3 图片 - 什么是指针4 4. 指针的使用 4.1. 方法中的指针 方法即为有接受者的函数，接受者可以是类型的实例变量或者是类型的实例指针变量。但两种效果不同。 1、类型的实例变量 func main(){ person := Person{\"vanyar\", 21} fmt.Printf(\"person\\n\", person.name, person.age) person.sayHi() person.ModifyAge(210) person.sayHi() } type Person struct { name string age int } func (p Person) sayHi() { fmt.Printf(\"SayHi -- This is %s, my age is %d\\n\",p.name, p.age) } func (p Person) ModifyAge(age int) { fmt.Printf(\"ModifyAge\") p.age = age } //输出结果 person SayHi -- This is vanyar, my age is 21 ModifyAgeSayHi -- This is vanyar, my age is 21 尽管 ModifyAge 方法修改了其age字段，可是方法里的p是person变量的一个副本，修改的只是副本的值。下一次调用sayHi方法的时候，还是person的副本，因此修改方法并不会生效。 即实例变量的方式并不会改变接受者本身的值。 2、类型的实例指针变量 func (p *Person) ChangeAge(age int) { fmt.Printf(\"ModifyAge\") p.age = age } Go会根据Person的示例类型，转换成指针类型再拷贝，即 person.ChangeAge会变成 (&person).ChangeAge。 指针类型的接受者，如果实例对象是值，那么go会转换成指针，然后再拷贝，如果本身就是指针对象，那么就直接拷贝指针实例。因为指针都指向一处值，就能修改对象了。 5. 零值与nil(空指针) 变量声明而没有赋值，默认为零值，不同类型零值不同，例如字符串零值为空字符串； 指针声明而没有赋值，默认为nil，即该指针没有任何指向。当指针没有指向的时候，不能对(*point)进行操作包括读取，否则会报空指针异常。 func main(){ // 声明一个指针变量 aPot 其类型也是 string var aPot *string fmt.Printf(\"aPot: %p %#v\\n\", &aPot, aPot) // 输出 aPot: 0xc42000c030 (*string)(nil) *aPot = \"This is a Pointer\" // 报错： panic: runtime error: invalid memory address or nil pointer dereference } 解决方法即给该指针分配一个指向,即初始化一个内存，并把该内存地址赋予指针变量，例如： // 声明一个指针变量 aPot 其类型也是 string var aPot *string fmt.Printf(\"aPot: %p %#v\\n\", &aPot, aPot) // 输出 aPot: 0xc42000c030 (*string)(nil) aPot = &aVar *aPot = \"This is a Pointer\" fmt.Printf(\"aVar: %p %#v \\n\", &aVar, aVar) // 输出 aVar: 0xc42000e240 \"This is a Pointer\" fmt.Printf(\"aPot: %p %#v %#v \\n\", &aPot, aPot, *aPot) // 输出 aPot: 0xc42000c030 (*string)(0xc42000e240) \"This is a Pointer\" 或者通过new开辟一个内存，并返回这个内存的地址。 var aNewPot *int aNewPot = new(int) *aNewPot = 217 fmt.Printf(\"aNewPot: %p %#v %#v \\n\", &aNewPot, aNewPot, *aNewPot) // 输出 aNewPot: 0xc42007a028 (*int)(0xc42006e1f0) 217 6. 总结 Golang提供了指针用于操作数据内存，并通过引用来修改变量。 只声明未赋值的变量，golang都会自动为其初始化为零值，基础数据类型的零值比较简单，引用类型和指针的零值都为nil，nil类型不能直接赋值，因此需要通过new开辟一个内存，或者通过make初始化数据类型，或者两者配合，然后才能赋值。 指针也是一种类型，不同于一般类型，指针的值是地址，这个地址指向其他的内存，通过指针可以读取其所指向的地址所存储的值。 函数方法的接受者，也可以是指针变量。无论普通接受者还是指针接受者都会被拷贝传入方法中，不同在于拷贝的指针，其指向的地方都一样，只是其自身的地址不一样。 参考： http://www.jianshu.com/p/d23f78a3922b http://www.jianshu.com/p/44b9429d7bef Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"concurrency/concurrency.html":{"url":"concurrency/concurrency.html","title":"并发基础","keywords":"","body":"并发基础 1. 概念 并发意味着程序在运行时有多个执行上下文，对应多个调用栈。 并发与并行的区别： 并发: 逻辑上具有处理多个同时性任务的能力。即看起来是多个任务同时执行，但并不一定同一个时刻执行，例如单核CPU，通过多线程共享CPU时间片串行执行(并发非并行)。 并行: 物理上同一时刻执行多个并发任务。一般依赖多核CPU达到多个任务在同一个时刻执行(并发且并行)。 并发的主流实现模型： 实现模型 说明 特点 多进程 操作系统层面的并发模式 处理简单，互不影响，但开销大 多线程 系统层面的并发模式 有效，开销较大，高并发时影响效率 基于回调的非阻塞/异步IO 多用于高并发服务器开发中 编程复杂，开销小 协程 用户态线程，不需要操作系统抢占调度，寄存于线程中 编程简单，结构简单，开销极小，但需要语言的支持 共享内存系统：线程之间采用共享内存的方式通信，通过加锁来避免死锁或资源竞争。 消息传递系统：将线程间共享状态封装在消息中，通过发送消息来共享内存，而非通过共享内存来通信。 2. 协程 执行体是个抽象的概念，在操作系统中分为三个级别：进程（process），进程内的线程（thread），进程内的协程（coroutine，轻量级线程）。协程的数量级可达到上百万个，进程和线程的数量级最多不超过一万个。Go语言中的协程叫goroutine，Go标准库提供的调用操作，IO操作都会出让CPU给其他goroutine，让协程间的切换管理不依赖系统的线程和进程，不依赖CPU的核心数量。 3. 并发通信 并发编程的难度在于协调，协调需要通过通信，并发通信模型分为共享数据和消息。共享数据即多个并发单元保持对同一个数据的引用，数据可以是内存数据块，磁盘文件，网络数据等。数据共享通过加锁的方式来避免死锁和资源竞争。Go语言则采取消息机制来通信，每个并发单元是独立的个体，有独立的变量，不同并发单元间这些变量不共享，每个并发单元的输入输出只通过消息的方式。 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"concurrency/goroutine.html":{"url":"concurrency/goroutine.html","title":"Goroutine","keywords":"","body":"Goroutine //定义调用体 func Add(x,y int){ z:=x+y fmt.Println(z) } //go关键字执行调用，即会产生一个goroutine并发执行 //当函数返回时，goroutine自动结束，如果有返回值,返回值会自动被丢弃 go Add(1,1) //并发执行 func main(){ for i:=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"concurrency/channel.html":{"url":"concurrency/channel.html","title":"Channel","keywords":"","body":"Channel channel就像管道的形式，是goroutine之间的通信方式，是进程内的通信方式，跨进程通信建议用分布式系统的方法来解决，例如Socket或http等通信协议。channel是类型相关，即一个channel只能传递一种类型的值，在声明时指定。 1. 基本语法 1.1. channel的声明 //1、channel声明，声明一个管道chanName，该管道可以传递的类型是ElementType //管道是一种复合类型，[chan ElementType],表示可以传递ElementType类型的管道[类似定语从句的修饰方法] var chanName chan ElementType var ch chan int //声明一个可以传递int类型的管道 var m map[string] chan bool //声明一个map，值的类型为可以传递bool类型的管道 1.2. 初始化 //2、初始化 ch:=make(chan int) //make一般用来声明一个复合类型，参数为复合类型的属性 1.3. 管道读写 //3、管道写入,把值想象成一个球，\" 1.4. select //4、每个case必须是一个IO操作，面向channel的操作，只执行其中的一个case操作，一旦满足则结束select过程 //面向channel的操作无非三种情况：成功读出；成功写入；即没有读出也没有写入 select{ case 2. 缓冲和超时机制 2.1. 缓冲机制 //1、缓冲机制：为管道指定空间长度，达到类似消息队列的效果 c:=make(chan int,1024) //第二个参数为缓冲区大小，与切片的空间大小类似 //通过range关键字来实现依次读取管道的数据，与数组或切片的range使用方法类似 for i :=range c{ fmt.Println(\"Received:\",i) } 2.2. 超时机制 //2、超时机制：利用select只要一个case满足，程序就继续执行而不考虑其他case的情况的特性实现超时机制 timeout:=make(chan bool,1) //设置一个超时管道 go func(){ time.Sleep(1e9) //设置超时时间，等待一分钟 timeout 2.3. channel的传递 //1、channel的传递，来实现Linux系统中管道的功能，以插件的方式增加数据处理的流程 type PipeData struct{ value int handler func(int) int //handler是属性？ next chan int //可以把[chan int]看成一个整体，表示放int类型的管道 } func handler(queue chan *PipeData){ //queue是一个存放*PipeDate类型的管道，可改变管道里的数据块内容 for data:=range queue{ //data的类型就是管道存放定义的类型，即PipeData data.next 2.4. 单向channel //2、单向channel：只能用于接收或发送数据，是对channel的一种使用限制 //单向channel的声明 var ch1 chan int //正常channel，可读写 var ch2 chan 2.5. 关闭channel //3、关闭channel，使用内置函数close()函数即可 close(ch) //判断channel是否关闭 x,ok:= Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"concurrency/parallelization.html":{"url":"concurrency/parallelization.html","title":"并行化","keywords":"","body":"多核并行化与同步锁 1. 多核并行化 //多核并行化 runtime.GOMAXPROCS(16) //设置环境变量GOMAXPROCS的值来控制使用多少个CPU核心 runtime.NumCPU() //来获取核心数 //出让时间片 runtime.Gosched() //在每个goroutine中控制何时出让时间片给其他goroutine 2. 同步锁 //同步锁 sync.Mutex //单读单写：占用Mutex后，其他goroutine只能等到其释放该Mutex sync.RWMutex //单写多读：会阻止写，不会阻止读 RLock() //读锁 Lock() //写锁 RUnlock() //解锁（读锁） Unlock() //解锁（写锁） //全局唯一性操作 //once的Do方法保证全局只调用指定函数(setup)一次，其他goroutine在调用到此函数是会阻塞，直到once调用结束才继续 once.Do(setup) Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "},"principle/go-scheduler.html":{"url":"principle/go-scheduler.html","title":"Goroutine调度","keywords":"","body":" 本文主要介绍Go的调度模型。 1. 线程实现模型 线程模型有三类：内核级线程模型、用户级线程模型、混合型线程模型。三者的区别主要在于线程与内核调度实体KSE(Kernel Scheduling Entity)之间的对应关系上。 内核调度实体KSE指操作系统内核调度器调度的对象实体，是内核调度的最小单元。 1.1. 线程模型对比 线程模型 用户线程与KSE之间的对应关系 特点 优点 缺点 内核级线程模型 1:1 1条用户线程对应一条内核进程/线程来调度，即以核心态线程实现。 具有和内核线程一致的优点，不同用户线程之间不会互相影响。可以利用多核系统的优势。 在大量线程的情况下，线程的创建、删除、切换的代价更昂贵，影响性能。 用户级线程模型 M:1 N条用户线程只由一条内核进程/线程调度，即以用户态线程实现。 线程的创建、删除和环境切换都很高效。 一旦一个线程发生阻塞，整个进程下的其他线程也会被阻塞。不能利用多核系统的优势。 混合型线程模型 M:N M条用户线程由N条内核线程动态关联。又称两级线程模型 可以快速地执行上下文切换，而且可以利用多核的优势。当某个线程发生阻塞可以调度出CPU关联到可以执行的线程上。目前Go就是采用这种线程模型。 动态关联机制实现复杂，需要用户或runtime自己去实现。 1.2. 线程模型示意图 2. G-P-M调度模型 调度模型: G-P-M对应关系： 2.1. 基本概念 M：machine，代表系统内核进程，用来执行G。（工人） P：processor，代表调度执行的上下文（context），维护了一个本地的goroutine的队列。（小推车） G：goroutine，代表goroutine，即执行的goroutine的数据结构及栈等。（砖头） 2.2. 基本流程 调度的本质是将G尽量均匀合理地安排给M来执行，其中P的作用就是来实现合理安排逻辑。 P的数量通过 GOMAXPROCS() 来设置，一般等于CPU的核数，对于一次代码执行设置好一般不会变。 P维护了一个本地的G队列（runqueue），包括正在执行和待执行的G，尽量保证所有的P都匹配一个M同时在执行G。 当P本地goroutine队列消费完，会从全局的goroutine队列（global runqueue）中拿goroutine到本地队列。P也会定期检查全局的goroutine队列，避免存在全局的goroutine没有被执行而\"饿死\"的现象。 P和M是动态形式的一对一的关系，P和G是动态形式的一对多的关系。 2.3. 抢占式调度（阻塞） 当goroutine发生阻塞的时候，可以通过P将剩余的G切换给新的M来执行，而不会导致剩余的G无法执行，如果没有M则创建M来匹配P。 当阻塞的goroutine返回后，进程会尝试获取一个上下文（Context）来执行这个goroutine。一般是先从其他进程中\"偷取\"一个Context，如果\"偷取\"不成功，则将goroutine放入全局的goroutine中。 2.4. 偷任务 P可以偷任务即goroutine，当某个P的本地G执行完，且全局没有G需要执行的时候，P可以去偷别的P还没有执行完的一半的G来给M执行，提高了G的执行效率。 参考： http://morsmachine.dk/go-scheduler Scalable Go Scheduler Design Doc Go Preemptive Scheduler Design Doc k2huang/blogpost/Go并发机制 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"text/json.html":{"url":"text/json.html","title":"Json处理","keywords":"","body":"JSON处理 JSON是一种轻量级的数据交换语言。 1. 解析JSON[Unmarshal(data []byte, v interface{})] 1.1. Unmarshal源码 /src/encoding/json/decode.go func Unmarshal(data []byte, v interface{}) error { // Check for well-formedness. // Avoids filling out half a data structure // before discovering a JSON syntax error. var d decodeState err := checkValid(data, &d.scan) if err != nil { return err } d.init(data) return d.unmarshal(v) } ... func (d *decodeState) unmarshal(v interface{}) (err error) { defer func() { if r := recover(); r != nil { if _, ok := r.(runtime.Error); ok { panic(r) } err = r.(error) } }() rv := reflect.ValueOf(v) if rv.Kind() != reflect.Ptr || rv.IsNil() { return &InvalidUnmarshalError{reflect.TypeOf(v)} } d.scan.reset() // We decode rv not rv.Elem because the Unmarshaler interface // test must be applied at the top level of the value. d.value(rv) return d.savedError } 1.2. 解析到结构体 package main import ( \"encoding/json\" \"fmt\" ) type Server struct { ServerName string ServerIP string } type Serverslice struct { Servers []Server } func main() { var s Serverslice str := `{\"servers\": [{\"serverName\":\"Shanghai_VPN\",\"serverIP\":\"127.0.0.1\"}, {\"serverName\":\"Beijing_VPN\",\"serverIP\":\"127.0.0.2\"}]}` err:=json.Unmarshal([]byte(str), &s) if err!=nil{ fmt.Println(err) } fmt.Println(s) } 说明 JSON格式与结构体一一对应，Unmarshal方法即将JSON文本转换成结构体。只会匹配结构体中的可导出字段，即首字母大写字段（类似java的public），匹配规则如下：json的key为Foo为例 先查找struct tag中含有Foo的可导出的struct字段（首字母大写） 其次查找字段名为Foo的可导出字段。 最后查找类似FOO或者FoO这类除首字母外，其他大小写不敏感的可导出字段。 1.3. 解析到interface 2. 生成JSON[Marshal(v interface{})] 2.1. Marshal源码 /src/encoding/json/encode.go func Marshal(v interface{}) ([]byte, error) { e := &encodeState{} err := e.marshal(v) if err != nil { return nil, err } return e.Bytes(), nil } ... func (e *encodeState) marshal(v interface{}) (err error) { defer func() { if r := recover(); r != nil { if _, ok := r.(runtime.Error); ok { panic(r) } if s, ok := r.(string); ok { panic(s) } err = r.(error) } }() e.reflectValue(reflect.ValueOf(v)) return nil } 2.2. 使用方法 package main import ( \"encoding/json\" \"fmt\" ) type Server struct { ServerName string `json:\"serverName,string\"` ServerIP string `json:\"serverIP,omitempty\"` } type Serverslice struct { Servers []Server `json:\"servers\"` } func main() { var s Serverslice s.Servers = append(s.Servers, Server{ServerName: \"Shanghai_VPN\", ServerIP: \"127.0.0.1\"}) s.Servers = append(s.Servers, Server{ServerName: \"Beijing_VPN\", ServerIP: \"127.0.02\"}) b, err := json.Marshal(s) if err != nil { fmt.Println(\"JSON ERR:\", err) } fmt.Println(string(b)) } 2.3. 说明 Marshal方法将结构体转换成json文本，匹配规则如下： 如果字段的tag是“-”，那么该字段不会输出到JSON。 如果tag中带有自定义名称，那么该自定义名称会出现在JSON字段名中。例如例子中的“serverName” 如果tag中带有“omitempty”选项，那么如果该字段值为空，就不会输出到JSON中。 如果字段类型是bool,string,int,int64等，而tag中带有“，string”选项，那么这个字段在输出到JSON的时候会把该字段对应的值转换成JSON字符串。 注意事项： Marshal只有在转换成功的时候才会返回数据，JSON对象只支持string作为key，如果要编码一个map,那么必须是map[string]T这种类型。（T为任意类型） Channel,complex和function不能被编码成JSON。 嵌套的数据不能编码，会进入死循环。 指针在编码时会输出指针指向的内容，而空指针会输出null。 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"text/file.html":{"url":"text/file.html","title":"文件操作","keywords":"","body":"文件操作 更多文件操作见Go的os包。 1. 目录操作 func Mkdir(name string, perm FileMode) error创建名称为 name 的目录，权限设置是 perm，例如 0777 func MkdirAll(path string, perm FileMode) error 根据 path 创建多级子目录，例如 astaxie/test1/test2。 func Remove(name string) error 删除名称为 name 的目录，当目录下有文件或者其他目录是会出错 func RemoveAll(path string) error 根据 path 删除多级子目录，如果 path 是单个名称，那么该目录不删除 2. 文件操作 2.1. 建立与打开文件 新建文件： func Create(name string) (file *File, err Error) 根据提供的文件名创建新的文件，返回一个文件对象，默认权限是 0666 的文件，返回的文件对象是可读写的。 func NewFile(fd uintptr, name string) *File 根据文件描述符创建相应的文件，返回一个文件对象 打开文件： func Open(name string) (file *File, err Error) 该方法打开一个名称为 name 的文件，但是是只读方式，内部实现其实调用了 OpenFile。 func OpenFile(name string, flag int, perm uint32) (file *File, err Error) 打开名称为 name 的文件，flag 是打开的方式，只读、读写等，perm 是权限 2.2. 写文件 写文件函数： func (file *File) Write(b []byte) (n int, err Error) 写入 byte 类型的信息到文件 func (file *File) WriteAt(b []byte, off int64) (n int, err Error) 在指定位置开始写入 byte 类型的信息 func (file *File) WriteString(s string) (ret int, err Error) 写入 string 信息到文件 package main import ( \"fmt\" \"os\" ) func main() { userFile := \"test.txt\" fout, err := os.Create(userFile) defer fout.Close() if err != nil { fmt.Println(userFile, err) return } for i := 0; i 2.3. 读文件 读文件函数： func (file *File) Read(b []byte) (n int, err Error) 读取数据到 b 中 func (file *File) ReadAt(b []byte, off int64) (n int, err Error) 从 off 开始读取数据到 b 中 package main import ( \"fmt\" \"os\" ) func main() { userFile := \"text.txt\" fl, err := os.Open(userFile) defer fl.Close() if err != nil { fmt.Println(userFile, err) return } buf := make([]byte, 1024) for { n, _ := fl.Read(buf) if 0 == n { break } os.Stdout.Write(buf[:n]) } } 2.4. 删除文件 Go 语言里面删除文件和删除文件夹是同一个函数 func Remove(name string) Error 调用该函数就可以删除文件名为 name 的文件 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"text/string.html":{"url":"text/string.html","title":"字符串处理","keywords":"","body":"字符串处理 字符串操作涉及的标准库有strings和strconv两个包 1. 字符串操作 函数 说明 func Contains(s, substr string) bool 字符串 s 中是否包含 substr，返回 bool 值 func Join(a []string, sep string) string 字符串链接，把 slice a 通过 sep 链接起来 func Index(s, sep string) int 在字符串 s 中查找 sep 所在的位置，返回位置值，找不到返回-1 func Repeat(s string, count int) string 重复 s 字符串 count 次，最后返回重复的字符串 func Replace(s, old, new string, n int) string 在 s 字符串中，把 old 字符串替换为 new 字符串，n 表示替换的次数，小于 0 表示全部替换 func Split(s, sep string) []string 把 s 字符串按照 sep 分割，返回 slice func Trim(s string, cutset string) string 在 s 字符串中去除 cutset 指定的字符串 func Fields(s string) []string 去除 s 字符串的空格符，并且按照空格分割返回 slice 2. 字符串转换 1、Append 系列函数将整数等转换为字符串后，添加到现有的字节数组中 package main import ( \"fmt\" \"strconv\" ) func main() { str := make([]byte, 0, 100) str = strconv.AppendInt(str, 4567, 10) str = strconv.AppendBool(str, false) str = strconv.AppendQuote(str, \"abcdefg\") str = strconv.AppendQuoteRune(str, '单') fmt.Println(string(str)) } 2、Format 系列函数把其他类型的转换为字符串 package main import ( \"fmt\" \"strconv\" ) func main() { a := strconv.FormatBool(false) b := strconv.FormatFloat(123.23, 'g', 12, 64) c := strconv.FormatInt(1234, 10) d := strconv.FormatUint(12345, 10) e := strconv.Itoa(1023) fmt.Println(a, b, c, d, e) } 3、Parse 系列函数把字符串转换为其他类型 package main import ( \"fmt\" \"strconv\" ) func main() { a, err := strconv.ParseBool(\"false\") if err != nil { fmt.Println(err) } b, err := strconv.ParseFloat(\"123.23\", 64) if err != nil { fmt.Println(err) } c, err := strconv.ParseInt(\"1234\", 10, 64) if err != nil { fmt.Println(err) } d, err := strconv.ParseUint(\"12345\", 10, 64) if err != nil { fmt.Println(err) } e, err := strconv.Itoa(\"1023\") if err != nil { fmt.Println(err) } fmt.Println(a, b, c, d, e) } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"text/template.html":{"url":"text/template.html","title":"模板语法","keywords":"","body":"基本语法 go 统一使用了 {{ 和 }} 作为左右标签，没有其他的标签符号。 使用 . 来访问当前位置的上下文 使用 $ 来引用当前模板根级的上下文 使用 $var 来访问创建的变量 模板中支持的 go 语言符号 {{\"string\"}} // 一般 string {{`raw string`}} // 原始 string {{'c'}} // byte {{print nil}} // nil 也被支持 模板中的 pipeline 可以是上下文的变量输出，也可以是函数通过管道传递的返回值 {{. | FuncA | FuncB | FuncC}} 当 pipeline 的值等于: false 或 0 nil 的指针或 interface 长度为 0 的 array, slice, map, string 那么这个 pipeline 被认为是空 1. if … else … end {{if pipeline}}{{end}} if 判断时，pipeline 为空时，相当于判断为 False 支持嵌套的循环 {{if .IsHome}} {{else}} {{if .IsAbout}}{{end}} {{end}} 也可以使用 else if 进行 {{if .IsHome}} {{else if .IsAbout}} {{else}} {{end}} 2. range … end {{range pipeline}}{{.}}{{end}} pipeline 支持的类型为 array, slice, map, channel range 循环内部的 . 改变为以上类型的子元素 对应的值长度为 0 时，range 不会执行，. 不会改变。 pages := []struct { Num int }{{10}, {20}, {30}} this.Data[\"Total\"] = 100 this.Data[\"Pages\"] = pages 使用 .Num 输出子元素的 Num 属性，使用 $. 引用模板中的根级上下文 {{range .Pages}} {{.Num}} of {{$.Total}} {{end}} 使用创建的变量，在这里和 go 中的 range 用法是相同的。 {{range $index, $elem := .Pages}} {{$index}} - {{$elem.Num}} - {{.Num}} of {{$.Total}} {{end}} range 也支持 else {{range .Pages}} {{else}} {{/* 当 .Pages 为空 或者 长度为 0 时会执行这里 */}} {{end}} 3. with … end {{with pipeline}}{{end}} with 用于重定向 pipeline {{with .Field.NestField.SubField}} {{.Var}} {{end}} 也可以对变量赋值操作 {{with $value := \"My name is %s\"}} {{printf . \"slene\"}} {{end}} with 也支持 else {{with pipeline}} {{else}} {{/* 当 pipeline 为空时会执行这里 */}} {{end}} 4. define define 可以用来定义自模板，可用于模块定义和模板嵌套 {{define \"loop\"}} {{.Name}} {{end}} 使用 template 调用模板 {{range .Items}} {{template \"loop\" .}} {{end}} 5. template {{template \"模板名\" pipeline}} 将对应的上下文 pipeline 传给模板，才可以在模板中调用 Beego 中支持直接载入文件模板 {{template \"path/to/head.html\" .}} Beego 会依据你设置的模板路径读取 head.html 在模板中可以接着载入其他模板，对于模板的分模块处理很有用处 6. 注释 允许多行文本注释，不允许嵌套 {{/* comment content support new line */ Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"test/test.html":{"url":"test/test.html","title":"单元测试","keywords":"","body":"1. Go中的测试框架 Go语言中自带有一个轻量级的测试框架testing和自带的go test命令来实现单元测试和性能测试，testing框架和其他语言中的测试框架类似，你可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例。 2. 单元测试原则 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 所有的测试用例函数必须是Test开头 测试用例会按照源代码中写的顺序依次执行 测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。 函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。 3. 示例 3.1. 源文件getest.go package gotest import ( \"errors\" ) func Division(a, b float64) (float64, error) { if b == 0 { return 0, errors.New(\"除数不能为0\") } return a / b, nil } 3.2. 测试文件gotest_test.go func Test_Division_2(t *testing.T) { if _, e := Division(6, 0); e == nil { //try a unit test on function t.Error(\"Division did not work as expected.\") // 如果不是如预期的那么就报错 } else { t.Log(\"one test passed.\", e) //记录一些你期望记录的信息 } } 4. 压力测试 压力测试用来检测函数(方法）的性能，和编写单元功能测试的方法类似。 压力测试用例必须遵循如下格式，其中XXX可以是任意字母数字的组合，但是首字母不能是小写字母 func BenchmarkXXX(b *testing.B) { ... } go test不会默认执行压力测试的函数，如果要执行压力测试需要带上参数-test.bench，语法:-test.bench=\"test_name_regex\",例如go test -test.bench=\".*\"表示测试全部的压力测试函数 在压力测试用例中,请记得在循环体内使用testing.B.N,以使测试可以正常的运行 文件名也必须以_test.go结尾 4.1. 示例 package gotest import ( \"testing\" ) func Benchmark_Division(b *testing.B) { for i := 0; i 执行测试命令 go test -file webbench_test.go -test.bench=\".*\" Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"test/gdb.html":{"url":"test/gdb.html","title":"GDB调试","keywords":"","body":"1. GDB简介 GDB是FSF(自由软件基金会)发布的一个强大的类UNIX系统下的程序调试工具。使用GDB可以做如下事情： 启动程序，可以按照开发者的自定义要求运行程序。 可让被调试的程序在开发者设定的调置的断点处停住。（断点可以是条件表达式） 当程序被停住时，可以检查此时程序中所发生的事。 动态的改变当前程序的执行环境。 目前支持调试Go程序的GDB版本必须大于7.1。 编译Go程序的时候需要注意以下几点 传递参数-ldflags \"-s\"，忽略debug的打印信息 传递-gcflags \"-N -l\" 参数，这样可以忽略Go内部做的一些优化，聚合变量和函数等优化，这样对于GDB调试来说非常困难，所以在编译的时候加入这两个参数避免这些优化。 2. 常用命令 2.1. list 简写命令l，用来显示源代码，默认显示十行代码，后面可以带上参数显示的具体行，例如：list 15，显示十行代码，其中第15行在显示的十行里面的中间，如下所示。 10 time.Sleep(2 * time.Second) 11 c 2.2. break 简写命令 b,用来设置断点，后面跟上参数设置断点的行数，例如b 10在第十行设置断点。 2.3. delete 简写命令 d,用来删除断点，后面跟上断点设置的序号，这个序号可以通过info breakpoints获取相应的设置的断点序号，如下是显示的设置断点序号。 Num Type Disp Enb Address What 2 breakpoint keep y 0x0000000000400dc3 in main.main at /home/xiemengjun/gdb.go:23 breakpoint already hit 1 time 2.4. backtrace 简写命令 bt,用来打印执行的代码过程，如下所示： #0 main.main () at /home/xiemengjun/gdb.go:23 #1 0x000000000040d61e in runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244 #2 0x000000000040d6c1 in schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267 #3 0x0000000000000000 in ?? () 2.5. info info命令用来显示信息，后面有几种参数，我们常用的有如下几种： 1、 info locals 显示当前执行的程序中的变量值 2、 info breakpoints 显示当前设置的断点列表 3、 info goroutines 显示当前执行的goroutine列表，如下代码所示,带*的表示当前执行的 * 1 running runtime.gosched * 2 syscall runtime.entersyscall 3 waiting runtime.gosched 4 runnable runtime.gosched 2.6. print 简写命令p，用来打印变量或者其他信息，后面跟上需要打印的变量名，当然还有一些很有用的函数$len()和$cap()，用来返回当前string、slices或者maps的长度和容量。 2.7. whatis 用来显示当前变量的类型，后面跟上变量名，例如whatis msg,显示如下： type = struct string 2.8. next 简写命令 n,用来单步调试，跳到下一步，当有断点之后，可以输入n跳转到下一步继续执行 2.9. coutinue 简称命令 c，用来跳出当前断点处，后面可以跟参数N，跳过多少次断点 2.10. set variable 该命令用来改变运行过程中的变量值，格式如：set variable = 3. 调试过程 3.1. 示例代码 package main import ( \"fmt\" \"time\" ) func counting(c chan 3.2. 调试步骤 编译文件，生成可执行文件gdbfile: go build -gcflags \"-N -l\" gdbfile.go 通过gdb命令启动调试： gdb gdbfile 启动之后首先看看这个程序是不是可以运行起来，只要输入run命令回车后程序就开始运行，程序正常的话可以看到程序输出如下，和我们在命令行直接执行程序输出是一样的： (gdb) run Starting program: /home/xiemengjun/gdbfile Starting main count: 0 count: 1 count: 2 count: 3 count: 4 count: 5 count: 6 count: 7 count: 8 count: 9 [LWP 2771 exited] [Inferior 1 (process 2771) exited normally] 好了，现在我们已经知道怎么让程序跑起来了，接下来开始给代码设置断点： (gdb) b 23 Breakpoint 1 at 0x400d8d: file /home/xiemengjun/gdbfile.go, line 23. (gdb) run Starting program: /home/xiemengjun/gdbfile Starting main [New LWP 3284] [Switching to LWP 3284] Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(\"count:\", count) 上面例子b 23表示在第23行设置了断点，之后输入run开始运行程序。现在程序在前面设置断点的地方停住了，我们需要查看断点相应上下文的源码，输入list就可以看到源码显示从当前停止行的前五行开始： (gdb) list 18 fmt.Println(msg) 19 bus := make(chan int) 20 msg = \"starting a gofunc\" 21 go counting(bus) 22 for count := range bus { 23 fmt.Println(\"count:\", count) 24 } 25 } 现在GDB在运行当前的程序的环境中已经保留了一些有用的调试信息，我们只需打印出相应的变量，查看相应变量的类型及值： (gdb) info locals count = 0 bus = 0xf840001a50 (gdb) p count $1 = 0 (gdb) p bus $2 = (chan int) 0xf840001a50 (gdb) whatis bus type = chan int 接下来该让程序继续往下执行，请继续看下面的命令 (gdb) c Continuing. count: 0 [New LWP 3303] [Switching to LWP 3303] Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(\"count:\", count) (gdb) c Continuing. count: 1 [Switching to LWP 3302] Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(\"count:\", count) 每次输入c之后都会执行一次代码，又跳到下一次for循环，继续打印出来相应的信息。设想目前需要改变上下文相关变量的信息，跳过一些过程，并继续执行下一步，得出修改后想要的结果： (gdb) info locals count = 2 bus = 0xf840001a50 (gdb) set variable count=9 (gdb) info locals count = 9 bus = 0xf840001a50 (gdb) c Continuing. count: 9 [Switching to LWP 3302] Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(\"count:\", count) 最后稍微思考一下，前面整个程序运行的过程中到底创建了多少个goroutine，每个goroutine都在做什么： (gdb) info goroutines * 1 running runtime.gosched * 2 syscall runtime.entersyscall 3 waiting runtime.gosched 4 runnable runtime.gosched (gdb) goroutine 1 bt #0 0x000000000040e33b in runtime.gosched () at /home/xiemengjun/go/src/pkg/runtime/proc.c:927 #1 0x0000000000403091 in runtime.chanrecv (c=void, ep=void, selected=void, received=void) at /home/xiemengjun/go/src/pkg/runtime/chan.c:327 #2 0x000000000040316f in runtime.chanrecv2 (t=void, c=void) at /home/xiemengjun/go/src/pkg/runtime/chan.c:420 #3 0x0000000000400d6f in main.main () at /home/xiemengjun/gdbfile.go:22 #4 0x000000000040d0c7 in runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244 #5 0x000000000040d16a in schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267 #6 0x0000000000000000 in ?? () 通过查看goroutines的命令我们可以清楚地了解goruntine内部是怎么执行的，每个函数的调用顺序已经明明白白地显示出来了。 参考《Go Web编程》 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"framework/cobra/cobra-usage.html":{"url":"framework/cobra/cobra-usage.html","title":"cobra 介绍","keywords":"","body":"1. Cobra简介 Cobra是一个cli接口模式的应用程序框架，同时也是生成该框架的命令行工具。用户可以通过help方式快速查看该二进制的使用方式。 Cobra主要包括以下部分 Command:一般表示action，即运行的二进制命令服务。同时可以拥有子命令（children commands）。 Args:命令执行相关参数。 Flags:二进制命令的配置参数，可对应配置文件。参数可分为全局参数和子命令参数。参考：pflag library。 2. 安装 通过以下操作可以在$GOPATH/bin安装cobra的二进制命令。 go get -u github.com/spf13/cobra/cobra 3. 使用 cobra命令行帮助信息如下： # cobra Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. Usage: cobra [command] Available Commands: add Add a command to a Cobra Application help Help about any command init Initialize a Cobra Application Flags: -a, --author string author name for copyright attribution (default \"YOUR NAME\") --config string config file (default is $HOME/.cobra.yaml) -h, --help help for cobra -l, --license string name of license for the project --viper use Viper for configuration (default true) Use \"cobra [command] --help\" for more information about a command. 3.1. cobra init # cobra init --help Initialize (cobra init) will create a new application, with a license and the appropriate structure for a Cobra-based CLI application. * If a name is provided, it will be created in the current directory; * If no name is provided, the current directory will be assumed; * If a relative path is provided, it will be created inside $GOPATH (e.g. github.com/spf13/hugo); * If an absolute path is provided, it will be created; * If the directory already exists but is empty, it will be used. Init will not use an existing directory with contents. Usage: cobra init [name] [flags] Aliases: init, initialize, initialise, create Flags: -h, --help help for init --pkg-name string fully qualified pkg name Global Flags: -a, --author string author name for copyright attribution (default \"YOUR NAME\") --config string config file (default is $HOME/.cobra.yaml) -l, --license string name of license for the project --viper use Viper for configuration (default true) 3.2. cobra add # cobra add --help Add (cobra add) will create a new command, with a license and the appropriate structure for a Cobra-based CLI application, and register it to its parent (default rootCmd). If you want your command to be public, pass in the command name with an initial uppercase letter. Example: cobra add server -> resulting in a new cmd/server.go Usage: cobra add [command name] [flags] Aliases: add, command Flags: -h, --help help for add -p, --parent string variable name of parent command for this command (default \"rootCmd\") Global Flags: -a, --author string author name for copyright attribution (default \"YOUR NAME\") --config string config file (default is $HOME/.cobra.yaml) -l, --license string name of license for the project --viper use Viper for configuration (default true) 参考： https://github.com/spf13/cobra https://github.com/spf13/cobra/blob/master/cobra/README.md Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 20:03:15 "},"framework/cobra/cobra-command.html":{"url":"framework/cobra/cobra-command.html","title":"cobra command","keywords":"","body":" 本文主要介绍cobra添加命令的具体使用操作。 1. cobra init cobra init 的具体使用参考 init 1.1. cobra init --pkg-name mkdir -p newApp && cd newApp cobra init --pkg-name github.com/spf13/newApp 执行以上命令，创建的文件目录结构如下： ./ ├── LICENSE ├── cmd │ ├── root.go └── main.go 1.2. main.go package main import \"github.com/huweihuang/cobra-demo/cmd\" func main() { cmd.Execute() } 1.3. cmd/root.go package cmd import ( \"fmt\" \"os\" \"github.com/spf13/cobra\" homedir \"github.com/mitchellh/go-homedir\" \"github.com/spf13/viper\" ) var cfgFile string // rootCmd represents the base command when called without any subcommands var rootCmd = &cobra.Command{ Use: \"cobra-demo\", Short: \"A brief description of your application\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, // Uncomment the following line if your bare application // has an action associated with it: // Run: func(cmd *cobra.Command, args []string) { }, } // Execute adds all child commands to the root command and sets flags appropriately. // This is called by main.main(). It only needs to happen once to the rootCmd. func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } func init() { cobra.OnInitialize(initConfig) // Here you will define your flags and configuration settings. // Cobra supports persistent flags, which, if defined here, // will be global for your application. rootCmd.PersistentFlags().StringVar(&cfgFile, \"config\", \"\", \"config file (default is $HOME/.cobra-demo.yaml)\") // Cobra also supports local flags, which will only run // when this action is called directly. rootCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } // initConfig reads in config file and ENV variables if set. func initConfig() { if cfgFile != \"\" { // Use config file from the flag. viper.SetConfigFile(cfgFile) } else { // Find home directory. home, err := homedir.Dir() if err != nil { fmt.Println(err) os.Exit(1) } // Search config in home directory with name \".cobra-demo\" (without extension). viper.AddConfigPath(home) viper.SetConfigName(\".cobra-demo\") } viper.AutomaticEnv() // read in environment variables that match // If a config file is found, read it in. if err := viper.ReadInConfig(); err == nil { fmt.Println(\"Using config file:\", viper.ConfigFileUsed()) } } 2. cobra add cobra add 的具体使用参考 add 2.1. cobra add command cobra add serve cobra add config cobra add create -p 'configCmd' # 在父命令config命令下创建子命令create,若没有指定-p,默认的父命令为rootCmd。 执行以上命令，创建的文件目录结构如下： ./ ├── LICENSE ├── cmd │ ├── config.go # rootCmd的子命令 │ ├── create.go # config的子命令 │ ├── root.go # 默认父命令 │ └── server.go # rootCmd的子命令 └── main.go 2.2. cmd/config.go package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) // configCmd represents the config command var configCmd = &cobra.Command{ Use: \"config\", Short: \"A brief description of your command\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your command. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"config called\") }, } func init() { rootCmd.AddCommand(configCmd) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags which will work for this command // and all subcommands, e.g.: // configCmd.PersistentFlags().String(\"foo\", \"\", \"A help for foo\") // Cobra supports local flags which will only run when this command // is called directly, e.g.: // configCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } 2.3. cmd/create.go create为config的子命令。 package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) // createCmd represents the create command var createCmd = &cobra.Command{ Use: \"create\", Short: \"A brief description of your command\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your command. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"create called\") }, } func init() { configCmd.AddCommand(createCmd) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags which will work for this command // and all subcommands, e.g.: // createCmd.PersistentFlags().String(\"foo\", \"\", \"A help for foo\") // Cobra supports local flags which will only run when this command // is called directly, e.g.: // createCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } 参考： https://github.com/spf13/cobra https://github.com/spf13/cobra/blob/master/cobra/README.md Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 20:05:02 "},"framework/cobra/cobra-flags.html":{"url":"framework/cobra/cobra-flags.html","title":"cobra flags","keywords":"","body":"添加Flags 1. Persistent Flags Persistent Flags表示该类参数可以被用于当前命令及其子命令。 例如，以下表示verbose参数可以被用于rootCmd及其子命令。 rootCmd.PersistentFlags().BoolVarP(&Verbose, \"verbose\", \"v\", false, \"verbose output\") 2. Local Flags Local Flags表示该类参数只能用于当前命令。 例如，以下表示source只能用于localCmd这个命令，不能用于其子命令。 localCmd.Flags().StringVarP(&Source, \"source\", \"s\", \"\", \"Source directory to read from\") 3. Local Flag on Parent Commands cobra默认只解析当前命令的local flags，通过开启Command.TraverseChildren参数，可以解析每个命令的local flags。 command := cobra.Command{ Use: \"print [OPTIONS] [COMMANDS]\", TraverseChildren: true, } 4. Bind Flags with Config 可以通过 viper来绑定flags。 var author string func init() { rootCmd.PersistentFlags().StringVar(&author, \"author\", \"YOUR NAME\", \"Author name for copyright attribution\") viper.BindPFlag(\"author\", rootCmd.PersistentFlags().Lookup(\"author\")) } 更多参考： viper documentation。 5. Required flags 默认添加的flags的可选参数，如果需要在二进制运行时添加必要参数，即当该参数没指定时会报错。可使用以下设置。 rootCmd.Flags().StringVarP(&Region, \"region\", \"r\", \"\", \"AWS region (required)\") rootCmd.MarkFlagRequired(\"region\") 参考： https://github.com/spf13/cobra https://github.com/spf13/cobra/blob/master/cobra/README.md Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-09-27 20:32:33 "},"web/beego/beego-introduction.html":{"url":"web/beego/beego-introduction.html","title":"Beego 介绍","keywords":"","body":"1. beego的使用 1.1. beego的安装 go get github.com/astaxie/beego 1.2. beego的升级 1、直接升级 go get -u github.com/astaxie/beego 2、源码下载升级 用户访问 https://github.com/astaxie/beego ,下载源码，然后覆盖到 $GOPATH/src/github.com/astaxie/beego 目录，然后通过本地执行安装就可以升级了： go install github.com/astaxie/beego 2. beego的架构 beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架。 2.1. beego架构图 图片 - architecture beego 是基于八大独立的模块构建的，是一个高度解耦的框架。 可以使用 cache 模块来做你的缓存逻辑；使用日志模块来记录你的操作信息；使用 config 模块来解析你各种格式的文件。 2.2. beego执行逻辑 图片 - flow 参考： https://beego.me/docs/intro/ https://beego.me/docs/install/ Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"web/beego/bee.html":{"url":"web/beego/bee.html","title":"Bee 工具使用","keywords":"","body":"1. bee工具 bee工具用来进行beego项目的创建、热编译、开发、测试、和部署。 安装: go get github.com/beego/bee 配置： 安装完之后，bee可执行文件默认存放在$GOPATH/bin里面，所以要把$GOPATH/bin添加到环境变量中。 2. bee命令 Bee is a tool for managing beego framework. Usage: bee command [arguments] The commands are: new create an application base on beego framework run run the app which can hot compile pack compress an beego project api create an api application base on beego framework bale packs non-Go files to Go source files version show the bee & beego version generate source code generator migrate run database migrations 说明： 2.1. new 在 $GOPATH/src的目录下执行bee new ，会在当前目录下生成以下文件： myproject ├── conf │ └── app.conf ├── controllers │ └── default.go ├── main.go ├── models ├── routers │ └── router.go ├── static │ ├── css │ ├── img │ └── js ├── tests │ └── default_test.go └── views └── index.tpl 2.2. run 必须在$GOPATH/src/appname下执行bee run，默认监听8080端口：http://localhost:8080/。 2.3. api api 命令就是用来创建 API 应用，生成以下文件：和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试。 apiproject ├── conf │ └── app.conf ├── controllers │ └── object.go │ └── user.go ├── docs │ └── doc.go ├── main.go ├── models │ └── object.go │ └── user.go ├── routers │ └── router.go └── tests └── default_test.go 2.4. pack pack 目录用来发布应用的时候打包，会把项目打包成 zip 包(apiproject.tar.gz)，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了： 2.5. generate 用来自动化的生成代码的，包含了从数据库一键生成model，还包含了scaffold。 2.6. migrate 这个命令是应用的数据库迁移命令，主要是用来每次应用升级，降级的SQL管理。 参考： https://beego.me/docs/install/bee.md Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"web/beego/beego-project.html":{"url":"web/beego/beego-project.html","title":"Beego 项目逻辑","keywords":"","body":"beego项目逻辑 1. 路由设置 1.1. beego.Router 入口文件main.go package main import ( _ \"quickstart/routers\" \"github.com/astaxie/beego\" ) func main() { beego.Run() } go中导入包中init函数的执行逻辑 图片 - init _ \"quickstart/routers\",包只引入执行了里面的init函数 package routers import ( \"quickstart/controllers\" \"github.com/astaxie/beego\" ) func init() { beego.Router(\"/\", &controllers.MainController{}) } 路由包里执行了路由注册beego.Router, 这个函数的功能是映射URL到controller，第一个参数是URL(用户请求的地址)，这里是 /，也就是访问的不带任何参数的URL，第二个参数是对应的 Controller，就是把请求分发到那个控制器来执行相应的逻辑。 1.2. beego.Run 解析配置文件 beego 会自动解析在 conf 目录下面的配置文件 app.conf，通过修改配置文件相关的属性，我们可以定义：开启的端口，是否开启 session，应用名称等信息。 执行用户的hookfunc beego会执行用户注册的hookfunc，默认的已经存在了注册mime，用户可以通过函数AddAPPStartHook注册自己的启动函数。 是否开启 session 会根据上面配置文件的分析之后判断是否开启 session，如果开启的话就初始化全局的 session。 是否编译模板 beego 会在启动的时候根据配置把 views 目录下的所有模板进行预编译，然后存在 map 里面，这样可以有效的提高模板运行的效率，无需进行多次编译。 是否开启文档功能 根据EnableDocs配置判断是否开启内置的文档路由功能 是否启动管理模块 beego 目前做了一个很酷的模块，应用内监控模块，会在 8088 端口做一个内部监听，我们可以通过这个端口查询到 QPS、CPU、内存、GC、goroutine、thread 等统计信息。 监听服务端口 这是最后一步也就是我们看到的访问 8080 看到的网页端口，内部其实调用了 ListenAndServe，充分利用了 goroutine 的优势，一旦 run 起来之后，我们的服务就监听在两个端口了，一个服务端口 8080 作为对外服务，另一个 8088 端口实行对内监控。 2. controller 逻辑 package controllers import ( \"github.com/astaxie/beego\" ) type MainController struct { beego.Controller } func (this *MainController) Get() { this.Data[\"Website\"] = \"beego.me\" this.Data[\"Email\"] = \"astaxie@gmail.com\" this.TplName = \"index.tpl\" } 1、声明了一个控制器 MainController，这个控制器里面内嵌了 beego.Controller，即Go 的嵌入方式，也就是 MainController 自动拥有了所有 beego.Controller 的方法。而 beego.Controller 拥有很多方法，其中包括 Init、Prepare、Post、Get、Delete、Head等方法。可以通过重写的方式来实现这些方法，以上例子重写了 Get 方法。 2、beego 是一个 RESTful 的框架，请求默认是执行对应 req.Method 的方法。例如浏览器的是 GET 请求，那么默认就会执行 MainController 下的 Get 方法。（用户可以改变这个行为，通过注册自定义的函数名）。 3、获取数据，赋值到 this.Data 中，这是一个用来存储输出数据的 map。 4、渲染模板，this.TplName 就是需要渲染的模板，这里指定了 index.tpl，如果用户不设置该参数，那么默认会去到模板目录的 Controller/.tpl 查找，例如上面的方法会去 maincontroller/get.tpl(文件、文件夹必须小写)。用户设置了模板之后系统会自动的调用 Render 函数（这个函数是在 beego.Controller 中实现的），所以无需用户自己来调用渲染。 5、如果不使用模板可以直接输出： func (this *MainController) Get() { this.Ctx.WriteString(\"hello\") } 3. model逻辑 model一般用来处理数据库操作，如果逻辑中存在可以复用的部分就可以抽象成一个model。 package models import ( \"loggo/utils\" \"path/filepath\" \"strconv\" \"strings\" ) var ( NotPV []string = []string{\"css\", \"js\", \"class\", \"gif\", \"jpg\", \"jpeg\", \"png\", \"bmp\", \"ico\", \"rss\", \"xml\", \"swf\"} ) const big = 0xFFFFFF func LogPV(urls string) bool { ext := filepath.Ext(urls) if ext == \"\" { return true } for _, v := range NotPV { if v == strings.ToLower(ext) { return false } } return true } 4. view逻辑 Controller中的this.TplName = \"index.tpl\"，设置显示的模板文件，默认支持 tpl 和 html 的后缀名，如果想设置其他后缀你可以调用 beego.AddTemplateExt 接口设置。beego 采用了 Go 语言默认的模板引擎，和 Go 的模板语法一样。 Beego Welcome to Beego! Beego is a simple & powerful Go web framework which is inspired by tornado and sinatra. Official website: {{.Website}} Contact me: {{.Email}} Controller 里面把数据赋值给了 data（map 类型），然后在模板中就直接通过 key 访问 .Website 和 .Email 。这样就做到了数据的输出。 5. 静态文件 网页往往包含了很多的静态文件，包括图片、JS、CSS 等 ├── static │ ├── css │ ├── img │ └── js beego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在/main.go文件中beego.Run()之前加入）： StaticDir[\"/static\"] = \"static\" 用户可以设置多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射（在/main.go文件中beego.Run()之前加入）： beego.SetStaticPath(\"/down1\", \"download1\") beego.SetStaticPath(\"/down2\", \"download2\") 这样用户访问 URL http://localhost:8080/down1/123.txt 则会请求 download1 目录下的 123.txt 文件。 参考： https://beego.me/docs/quickstart/router.md https://beego.me/docs/quickstart/controller.md https://beego.me/docs/quickstart/model.md https://beego.me/docs/quickstart/view.md https://beego.me/docs/quickstart/static.md Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"web/beego/beego-log.html":{"url":"web/beego/beego-log.html","title":"Beego 日志处理","keywords":"","body":"1. 使用入门 beego 的日志处理是基于 logs 模块搭建的，内置了一个变量 BeeLogger，默认已经是 logs.BeeLogger 类型，初始化了 console，也就是默认输出到 console。 beego.Emergency(\"this is emergency\") beego.Alert(\"this is alert\") beego.Critical(\"this is critical\") beego.Error(\"this is error\") beego.Warning(\"this is warning\") beego.Notice(\"this is notice\") beego.Informational(\"this is informational\") beego.Debug(\"this is debug\") 2. 设置输出 我们的程序往往期望把信息输出到 log 中，现在设置输出到文件很方便，如下所示： beego.SetLogger(\"file\", `{\"filename\":\"logs/test.log\"}`) 这个默认情况就会同时输出到两个地方，一个 console，一个 file，如果只想输出到文件，就需要调用删除操作： beego.BeeLogger.DelLogger(\"console\") 3. 设置级别 LevelEmergency LevelAlert LevelCritical LevelError LevelWarning LevelNotice LevelInformational LevelDebug 级别依次降低，默认全部打印，但是一般我们在部署环境，可以通过设置级别设置日志级别： beego.SetLevel(beego.LevelInformational) 4. 输出文件名和行号 日志默认不输出调用的文件名和文件行号,如果你期望输出调用的文件名和文件行号,可以如下设置 beego.SetLogFuncCall(true) 开启传入参数 true, 关闭传入参数 false, 默认是关闭的。 5. beego/logs模块的使用 是一个用来处理日志的库，目前支持的引擎有 file、console、net、smtp，可以通过如下方式进行安装： go get github.com/astaxie/beego/logs 5.1. 通用方式 首先引入包： import ( \"github.com/astaxie/beego/logs\" ) 然后添加输出引擎（log 支持同时输出到多个引擎），这里我们以 console 为例，第一个参数是引擎名（包括：console、file、conn、smtp、es、multifile） logs.SetLogger(\"console\") 添加输出引擎也支持第二个参数,用来表示配置信息，详细的配置请看下面介绍： logs.SetLogger(logs.AdapterFile,`{\"filename\":\"project.log\",\"level\":7,\"maxlines\":0,\"maxsize\":0,\"daily\":true,\"maxdays\":10}`) 示例： package main import ( \"github.com/astaxie/beego/logs\" ) func main() { //an official log.Logger l := logs.GetLogger() l.Println(\"this is a message of http\") //an official log.Logger with prefix ORM logs.GetLogger(\"ORM\").Println(\"this is a message of orm\") logs.Debug(\"my book is bought in the year of \", 2016) logs.Info(\"this %s cat is %v years old\", \"yellow\", 3) logs.Warn(\"json is a type of kv like\", map[string]int{\"key\": 2016}) logs.Error(1024, \"is a very\", \"good game\") logs.Critical(\"oh,crash\") } 5.2. 输出文件名和行号 日志默认不输出调用的文件名和文件行号,如果你期望输出调用的文件名和文件行号,可以如下设置 logs.EnableFuncCallDepth(true) 开启传入参数 true,关闭传入参数 false,默认是关闭的. 如果你的应用自己封装了调用 log 包,那么需要设置 SetLogFuncCallDepth,默认是 2,也就是直接调用的层级,如果你封装了多层,那么需要根据自己的需求进行调整. logs.SetLogFuncCallDepth(3) 5.3. 异步输出日志 为了提升性能, 可以设置异步输出: logs.Async() 异步输出允许设置缓冲 chan 的大小 logs.Async(1e3) 5.4. 引擎配置 console 可以设置输出的级别，或者不设置保持默认，默认输出到 os.Stdout： logs.SetLogger(logs.AdapterConsole, `{\"level\":1}`) file 设置的例子如下所示： logs.SetLogger(logs.AdapterFile, `{\"filename\":\"test.log\"}`) 主要的参数如下说明： filename 保存的文件名 maxlines 每个文件保存的最大行数，默认值 1000000 maxsize 每个文件保存的最大尺寸，默认值是 1 daily 是否按照每天 logrotate，默认是 true maxdays 文件最多保存多少天，默认保存 7 天 rotate 是否开启 logrotate，默认是 true level 日志保存的时候的级别，默认是 Trace 级别 perm 日志文件权限 multifile 设置的例子如下所示： logs.SetLogger(logs.AdapterMultiFile, ``{\"filename\":\"test.log\",\"separate\":[\"emergency\", \"alert\", \"critical\", \"error\", \"warning\", \"notice\", \"info\", \"debug\"]}``) 主要的参数如下说明(除 separate 外,均与file相同)： filename 保存的文件名 maxlines 每个文件保存的最大行数，默认值 1000000 maxsize 每个文件保存的最大尺寸，默认值是 1 daily 是否按照每天 logrotate，默认是 true maxdays 文件最多保存多少天，默认保存 7 天 rotate 是否开启 logrotate，默认是 true level 日志保存的时候的级别，默认是 Trace 级别 perm 日志文件权限 separate 需要单独写入文件的日志级别,设置后命名类似 test.error.log conn 网络输出，设置的例子如下所示： logs.SetLogger(logs.AdapterConn, `{\"net\":\"tcp\",\"addr\":\":7020\"}`) 主要的参数说明如下： reconnectOnMsg 是否每次链接都重新打开链接，默认是 false reconnect 是否自动重新链接地址，默认是 false net 发开网络链接的方式，可以使用 tcp、unix、udp 等 addr 网络链接的地址 level 日志保存的时候的级别，默认是 Trace 级别 smtp 邮件发送，设置的例子如下所示： logs.SetLogger(logs.AdapterMail, `{\"username\":\"beegotest@gmail.com\",\"password\":\"xxxxxxxx\",\"host\":\"smtp.gmail.com:587\",\"sendTos\":[\"xiemengjun@gmail.com\"]}`) 主要的参数说明如下： username smtp 验证的用户名 password smtp 验证密码 host 发送的邮箱地址 sendTos 邮件需要发送的人，支持多个 subject 发送邮件的标题，默认是 Diagnostic message from server level 日志发送的级别，默认是 Trace 级别 ElasticSearch 输出到 ElasticSearch: logs.SetLogger(logs.AdapterEs, `{\"dsn\":\"http://localhost:9200/\",\"level\":1}` 参考文章： https://beego.me/docs/mvc/controller/logs.md https://beego.me/docs/module/logs.md Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"web/golang-http-execution-flow.html":{"url":"web/golang-http-execution-flow.html","title":"Http包源码分析","keywords":"","body":"1. http包建立web服务器 package main import ( \"fmt\" \"log\" \"net/http\" \"strings\" ) func sayhelloName(w http.ResponseWriter, r *http.Request) { r.ParseForm() fmt.Println(r.Form) fmt.Println(\"path\", r.URL.Path) fmt.Println(\"scheme\", r.URL.Scheme) fmt.Println(r.Form[\"url_long\"]) for k, v := range r.Form { fmt.Println(\"key:\", k) fmt.Println(\"val:\", strings.Join((v), \"\")) } fmt.Println(w, \"hello world\") } func main() { http.HandleFunc(\"/\", sayhelloName) err := http.ListenAndServe(\":9090\", nil) if err != nil { log.Fatal(\"ListenAndServe:\", err) } } 2. http包的运行机制 相关源码位于：/src/net/http/server.go 服务端的几个概念 Request：用户请求的信息，用来解析用户的请求信息，包括post，get，Cookie，url等信息。 Response:服务器需要反馈给客户端的信息。 Conn：用户的每次请求链接。 Handle:处理请求和生成返回信息的处理逻辑。 Go实现web服务的流程 创建Listen Socket，监听指定的端口，等待客户端请求到来。 Listen Socket接受客户端的请求，得到Client Socket，接下来通过Client Socket与客户端通信。 处理客户端请求，首先从Client Socket读取HTTP请求的协议头，如果是POST方法，还可能要读取客户端提交的数据，然后交给相应的handler处理请求，handler处理完，将数据通过Client Socket返回给客户端。 2.1. http包执行流程图 图片 - image2017-3-5 22-46-35 2.2. 注册路由[HandleFunc] http.HandlerFunc类型默认实现了ServeHTTP的接口。 // The HandlerFunc type is an adapter to allow the use of // ordinary functions as HTTP handlers. If f is a function // with the appropriate signature, HandlerFunc(f) is a // Handler that calls f. type HandlerFunc func(ResponseWriter, *Request) // ServeHTTP calls f(w, r). func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } // HandleFunc registers the handler function for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) } ... // HandleFunc registers the handler function for the given pattern. func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { mux.Handle(pattern, HandlerFunc(handler)) } Handle // Handle registers the handler for the given pattern. // If a handler already exists for pattern, Handle panics. func (mux *ServeMux) Handle(pattern string, handler Handler) { mux.mu.Lock() defer mux.mu.Unlock() if pattern == \"\" { panic(\"http: invalid pattern \" + pattern) } if handler == nil { panic(\"http: nil handler\") } if mux.m[pattern].explicit { panic(\"http: multiple registrations for \" + pattern) } mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern} if pattern[0] != '/' { mux.hosts = true } // Helpful behavior: // If pattern is /tree/, insert an implicit permanent redirect for /tree. // It can be overridden by an explicit registration. n := len(pattern) if n > 0 && pattern[n-1] == '/' && !mux.m[pattern[0:n-1]].explicit { // If pattern contains a host name, strip it and use remaining // path for redirect. path := pattern if pattern[0] != '/' { // In pattern, at least the last character is a '/', so // strings.Index can't be -1. path = pattern[strings.Index(pattern, \"/\"):] } url := &url.URL{Path: path} mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern} } } 2.3. 如何监听端口 通过ListenAndServe来监听，底层实现：初始化一个server对象，调用net.Listen(\"tcp\",addr)，也就是底层用TCP协议搭建了一个服务，监听设置的端口。然后调用srv.Serve(net.Listener)函数，这个函数处理接收客户端的请求信息。这个函数里起了一个for循环，通过Listener接收请求，创建conn，开一个goroutine，把请求的数据当作参数给conn去服务：go c.serve()，即每次请求都是在新的goroutine中去服务，利于高并发。 src/net/http/server.go // ListenAndServe always returns a non-nil error. func ListenAndServe(addr string, handler Handler) error { server := &Server{Addr: addr, Handler: handler} return server.ListenAndServe() } ... // ListenAndServe listens on the TCP network address srv.Addr and then // calls Serve to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // If srv.Addr is blank, \":http\" is used. // ListenAndServe always returns a non-nil error. func (srv *Server) ListenAndServe() error { addr := srv.Addr if addr == \"\" { addr = \":http\" } ln, err := net.Listen(\"tcp\", addr) if err != nil { return err } return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)}) } 2.4. 如何接收客户端的请求 srv.Serve // Serve accepts incoming connections on the Listener l, creating a // new service goroutine for each. The service goroutines read requests and // then call srv.Handler to reply to them. // Serve always returns a non-nil error. func (srv *Server) Serve(l net.Listener) error { defer l.Close() if fn := testHookServerServe; fn != nil { fn(srv, l) } var tempDelay time.Duration // how long to sleep on accept failure if err := srv.setupHTTP2(); err != nil { return err } for { rw, e := l.Accept() if e != nil { if ne, ok := e.(net.Error); ok && ne.Temporary() { if tempDelay == 0 { tempDelay = 5 * time.Millisecond } else { tempDelay *= 2 } if max := 1 * time.Second; tempDelay > max { tempDelay = max } srv.logf(\"http: Accept error: %v; retrying in %v\", e, tempDelay) time.Sleep(tempDelay) continue } return e } tempDelay = 0 c := srv.newConn(rw) c.setState(c.rwc, StateNew) // before Serve can return go c.serve() } } 关键代码： c := srv.newConn(rw) c.setState(c.rwc, StateNew) // before Serve can return go c.serve() newConn // Create new connection from rwc. func (srv *Server) newConn(rwc net.Conn) *conn { c := &conn{ server: srv, rwc: rwc, } if debugServerConnections { c.rwc = newLoggingConn(\"server\", c.rwc) } return c } 2.5. 如何分配handler conn先解析request：c.readRequest()，获取相应的handler:handler:=c.server.Handler，即ListenAndServe的第二个参数，因为值为nil，所以默认handler=DefaultServeMux。该变量是一个路由器，用来匹配url跳转到其相应的handle函数。其中http.HandleFunc(\"/\",sayhelloName)即注册了请求“/”的路由规则，当uri为“/”时，路由跳转到函数sayhelloName。DefaultServeMux会调用ServeHTTP方法，这个方法内部调用sayhelloName本身，最后写入response的信息反馈给客户端。 2.5.1. c.serve() // Serve a new connection. func (c *conn) serve() { ... for { w, err := c.readRequest() ... serverHandler{c.server}.ServeHTTP(w, w.req) .. } } 2.5.2. c.readRequest() // Read next request from connection. func (c *conn) readRequest() (w *response, err error) { if c.hijacked() { return nil, ErrHijacked } if d := c.server.ReadTimeout; d != 0 { c.rwc.SetReadDeadline(time.Now().Add(d)) } if d := c.server.WriteTimeout; d != 0 { defer func() { c.rwc.SetWriteDeadline(time.Now().Add(d)) }() } c.r.setReadLimit(c.server.initialReadLimitSize()) c.mu.Lock() // while using bufr if c.lastMethod == \"POST\" { // RFC 2616 section 4.1 tolerance for old buggy clients. peek, _ := c.bufr.Peek(4) // ReadRequest will get err below c.bufr.Discard(numLeadingCRorLF(peek)) } req, err := readRequest(c.bufr, keepHostHeader) c.mu.Unlock() if err != nil { if c.r.hitReadLimit() { return nil, errTooLarge } return nil, err } c.lastMethod = req.Method c.r.setInfiniteReadLimit() hosts, haveHost := req.Header[\"Host\"] if req.ProtoAtLeast(1, 1) && (!haveHost || len(hosts) == 0) { return nil, badRequestError(\"missing required Host header\") } if len(hosts) > 1 { return nil, badRequestError(\"too many Host headers\") } if len(hosts) == 1 && !validHostHeader(hosts[0]) { return nil, badRequestError(\"malformed Host header\") } for k, vv := range req.Header { if !validHeaderName(k) { return nil, badRequestError(\"invalid header name\") } for _, v := range vv { if !validHeaderValue(v) { return nil, badRequestError(\"invalid header value\") } } } delete(req.Header, \"Host\") req.RemoteAddr = c.remoteAddr req.TLS = c.tlsState if body, ok := req.Body.(*body); ok { body.doEarlyClose = true } w = &response{ conn: c, req: req, reqBody: req.Body, handlerHeader: make(Header), contentLength: -1, } w.cw.res = w w.w = newBufioWriterSize(&w.cw, bufferBeforeChunkingSize) return w, nil } 2.5.3. ServeHTTP(w, w.req) func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { handler := sh.srv.Handler if handler == nil { handler = DefaultServeMux } if req.RequestURI == \"*\" && req.Method == \"OPTIONS\" { handler = globalOptionsHandler{} } handler.ServeHTTP(rw, req) } 2.5.4. DefaultServeMux type ServeMux struct { mu sync.RWMutex m map[string]muxEntry hosts bool // whether any patterns contain hostnames } type muxEntry struct { explicit bool h Handler pattern string } // NewServeMux allocates and returns a new ServeMux. func NewServeMux() *ServeMux { return &ServeMux{m: make(map[string]muxEntry)} } // DefaultServeMux is the default ServeMux used by Serve. var DefaultServeMux = NewServeMux() handler接口的定义 type Handler interface { ServeHTTP(ResponseWriter, *Request) } 2.5.5. ServeMux.ServeHTTP // ServeHTTP dispatches the request to the handler whose // pattern most closely matches the request URL. func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) { if r.RequestURI == \"*\" { if r.ProtoAtLeast(1, 1) { w.Header().Set(\"Connection\", \"close\") } w.WriteHeader(StatusBadRequest) return } h, _ := mux.Handler(r) h.ServeHTTP(w, r) } mux.Handler(r) // Handler returns the handler to use for the given request, // consulting r.Method, r.Host, and r.URL.Path. It always returns // a non-nil handler. If the path is not in its canonical form, the // handler will be an internally-generated handler that redirects // to the canonical path. // // Handler also returns the registered pattern that matches the // request or, in the case of internally-generated redirects, // the pattern that will match after following the redirect. // // If there is no registered handler that applies to the request, // Handler returns a ``page not found'' handler and an empty pattern. func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) { if r.Method != \"CONNECT\" { if p := cleanPath(r.URL.Path); p != r.URL.Path { _, pattern = mux.handler(r.Host, p) url := *r.URL url.Path = p return RedirectHandler(url.String(), StatusMovedPermanently), pattern } } return mux.handler(r.Host, r.URL.Path) } // handler is the main implementation of Handler. // The path is known to be in canonical form, except for CONNECT methods. func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) { mux.mu.RLock() defer mux.mu.RUnlock() // Host-specific pattern takes precedence over generic ones if mux.hosts { h, pattern = mux.match(host + path) } if h == nil { h, pattern = mux.match(path) } if h == nil { h, pattern = NotFoundHandler(), \"\" } return } 2.6. http连接处理流程图 图片 - image2017-3-5 23-50-6 3. http的执行流程总结 1、首先调用Http.HandleFunc，按如下顺序执行： 调用了DefaultServerMux的HandleFunc。 调用了DefaultServerMux的Handle。 往DefaultServerMux的map[string] muxEntry中增加对应的handler和路由规则。 2、调用http.ListenAndServe(\":9090\",nil)，按如下顺序执行： 实例化Server。 调用Server的ListenAndServe()。 调用net.Listen(\"tcp\",addr)监听端口。 启动一个for循环，在循环体中Accept请求。 对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()。 读取每个请求的内容w,err:=c.readRequest()。 判断handler是否为空，如果没有设置handler，handler默认设置为DefaultServeMux。 调用handler的ServeHttp。 根据request选择handler，并且进入到这个handler的ServeHTTP, mux.handler(r).ServeHTTP(w,r) 选择handler 判断是否有路由能满足这个request（循环遍历ServeMux的muxEntry）。 如果有路由满足，调用这个路由handler的ServeHttp。 如果没有路由满足，调用NotFoundHandler的ServeHttp。 4. 自定义路由 Go支持外部实现路由器，ListenAndServe的第二个参数就是配置外部路由器，它是一个Handler接口。即外部路由器实现Hanlder接口。 Handler接口： type Handler interface { ServeHTTP(ResponseWriter, *Request) } 自定义路由 package main import ( \"fmt\" \"net/http\" ) type MyMux struct{ } func (p *MyMux) ServeHTTP(w http.ResponseWriter,r *http.Request){ if r.URL.Path==\"/\"{ sayhelloName(w,r) return } http.NotFound(w,r) return } func sayhelloName(w http.ResponseWriter,r *http.Request){ fmt.Fprintln(w,\"Hello myroute\") } func main() { mux:=&MyMux{} http.ListenAndServe(\":9090\",mux) } 文章参考： 《Go web编程》 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:10 "},"code/confd-code-analysis.html":{"url":"code/confd-code-analysis.html","title":"confd源码分析","keywords":"","body":" confd的源码参考：https://github.com/kelseyhightower/confd 本文分析的confd的版本是v0.16.0，代码参考：https://github.com/kelseyhightower/confd/tree/v0.16.0。 1. Main confd的入口函数 Main 函数，先解析参数，如果是打印版本信息的参数，则执行打印版本的命令。 func main() { flag.Parse() if config.PrintVersion { fmt.Printf(\"confd %s (Git SHA: %s, Go Version: %s)\\n\", Version, GitSHA, runtime.Version()) os.Exit(0) } ... } 其中版本信息记录在https://github.com/kelseyhightower/confd/blob/v0.16.0/version.go#L3 const Version = \"0.16.0\" 1.1. initConfig 初始化配置文件。 if err := initConfig(); err != nil { log.Fatal(err.Error()) } initConfig函数对基本的配置内容做初始化，当没有指定后端存储的时候，设置默认存储。 // initConfig initializes the confd configuration by first setting defaults, // then overriding settings from the confd config file, then overriding // settings from environment variables, and finally overriding // settings from flags set on the command line. // It returns an error if any. func initConfig() error { _, err := os.Stat(config.ConfigFile) if os.IsNotExist(err) { log.Debug(\"Skipping confd config file.\") } else { log.Debug(\"Loading \" + config.ConfigFile) configBytes, err := ioutil.ReadFile(config.ConfigFile) if err != nil { return err } _, err = toml.Decode(string(configBytes), &config) if err != nil { return err } } // Update config from environment variables. processEnv() if config.SecretKeyring != \"\" { kr, err := os.Open(config.SecretKeyring) if err != nil { log.Fatal(err.Error()) } defer kr.Close() config.PGPPrivateKey, err = ioutil.ReadAll(kr) if err != nil { log.Fatal(err.Error()) } } if config.LogLevel != \"\" { log.SetLevel(config.LogLevel) } if config.SRVDomain != \"\" && config.SRVRecord == \"\" { config.SRVRecord = fmt.Sprintf(\"_%s._tcp.%s.\", config.Backend, config.SRVDomain) } // Update BackendNodes from SRV records. if config.Backend != \"env\" && config.SRVRecord != \"\" { log.Info(\"SRV record set to \" + config.SRVRecord) srvNodes, err := getBackendNodesFromSRV(config.SRVRecord) if err != nil { return errors.New(\"Cannot get nodes from SRV records \" + err.Error()) } switch config.Backend { case \"etcd\": vsm := make([]string, len(srvNodes)) for i, v := range srvNodes { vsm[i] = config.Scheme + \"://\" + v } srvNodes = vsm } config.BackendNodes = srvNodes } if len(config.BackendNodes) == 0 { switch config.Backend { case \"consul\": config.BackendNodes = []string{\"127.0.0.1:8500\"} case \"etcd\": peerstr := os.Getenv(\"ETCDCTL_PEERS\") if len(peerstr) > 0 { config.BackendNodes = strings.Split(peerstr, \",\") } else { config.BackendNodes = []string{\"http://127.0.0.1:4001\"} } case \"etcdv3\": config.BackendNodes = []string{\"127.0.0.1:2379\"} case \"redis\": config.BackendNodes = []string{\"127.0.0.1:6379\"} case \"vault\": config.BackendNodes = []string{\"http://127.0.0.1:8200\"} case \"zookeeper\": config.BackendNodes = []string{\"127.0.0.1:2181\"} } } // Initialize the storage client log.Info(\"Backend set to \" + config.Backend) if config.Watch { unsupportedBackends := map[string]bool{ \"dynamodb\": true, \"ssm\": true, } if unsupportedBackends[config.Backend] { log.Info(fmt.Sprintf(\"Watch is not supported for backend %s. Exiting...\", config.Backend)) os.Exit(1) } } if config.Backend == \"dynamodb\" && config.Table == \"\" { return errors.New(\"No DynamoDB table configured\") } config.ConfigDir = filepath.Join(config.ConfDir, \"conf.d\") config.TemplateDir = filepath.Join(config.ConfDir, \"templates\") return nil } 1.2. storeClient log.Info(\"Starting confd\") storeClient, err := backends.New(config.BackendsConfig) if err != nil { log.Fatal(err.Error()) } 根据配置文件中的存储后端类型构造一个存储后端的client，其中主要调用的函数为backends.New(config.BackendsConfig)。 当没有设置存储后端时，默认为etcd。 if config.Backend == \"\" { config.Backend = \"etcd\" } backendNodes := config.BackendNodes 当存储后端为file类型的处理。 if config.Backend == \"file\" { log.Info(\"Backend source(s) set to \" + strings.Join(config.YAMLFile, \", \")) } else { log.Info(\"Backend source(s) set to \" + strings.Join(backendNodes, \", \")) } 最后再根据不同类型的存储后端，调用不同的存储后端构建函数，本文只分析redis类型的存储后端。 switch config.Backend { case \"consul\": return consul.New(config.BackendNodes, config.Scheme, config.ClientCert, config.ClientKey, config.ClientCaKeys, config.BasicAuth, config.Username, config.Password, ) case \"etcd\": // Create the etcd client upfront and use it for the life of the process. // The etcdClient is an http.Client and designed to be reused. return etcd.NewEtcdClient(backendNodes, config.ClientCert, config.ClientKey, config.ClientCaKeys, config.BasicAuth, config.Username, config.Password) case \"etcdv3\": return etcdv3.NewEtcdClient(backendNodes, config.ClientCert, config.ClientKey, config.ClientCaKeys, config.BasicAuth, config.Username, config.Password) case \"zookeeper\": return zookeeper.NewZookeeperClient(backendNodes) case \"rancher\": return rancher.NewRancherClient(backendNodes) case \"redis\": return redis.NewRedisClient(backendNodes, config.ClientKey, config.Separator) case \"env\": return env.NewEnvClient() case \"file\": return file.NewFileClient(config.YAMLFile, config.Filter) case \"vault\": vaultConfig := map[string]string{ \"app-id\": config.AppID, \"user-id\": config.UserID, \"role-id\": config.RoleID, \"secret-id\": config.SecretID, \"username\": config.Username, \"password\": config.Password, \"token\": config.AuthToken, \"cert\": config.ClientCert, \"key\": config.ClientKey, \"caCert\": config.ClientCaKeys, \"path\": config.Path, } return vault.New(backendNodes[0], config.AuthType, vaultConfig) case \"dynamodb\": table := config.Table log.Info(\"DynamoDB table set to \" + table) return dynamodb.NewDynamoDBClient(table) case \"ssm\": return ssm.New() } return nil, errors.New(\"Invalid backend\") 其中redis类型的存储后端调用了NewRedisClient方法来构造redis的client。 case \"redis\": return redis.NewRedisClient(backendNodes, config.ClientKey, config.Separator) 其中涉及三个参数： backendNodes：redis的节点地址。 ClientKey：redis的密码。 Separator：查找redis键的分隔符，该参数只用在redis类型。 NewRedisClient函数方法如下： // NewRedisClient returns an *redis.Client with a connection to named machines. // It returns an error if a connection to the cluster cannot be made. func NewRedisClient(machines []string, password string, separator string) (*Client, error) { if separator == \"\" { separator = \"/\" } log.Debug(fmt.Sprintf(\"Redis Separator: %#v\", separator)) var err error clientWrapper := &Client{machines: machines, password: password, separator: separator, client: nil, pscChan: make(chan watchResponse), psc: redis.PubSubConn{Conn: nil} } clientWrapper.client, _, err = tryConnect(machines, password, true) return clientWrapper, err } 1.3. processor stopChan := make(chan bool) doneChan := make(chan bool) errChan := make(chan error, 10) var processor template.Processor switch { case config.Watch: processor = template.WatchProcessor(config.TemplateConfig, stopChan, doneChan, errChan) default: processor = template.IntervalProcessor(config.TemplateConfig, stopChan, doneChan, errChan, config.Interval) } go processor.Process() 当开启watch参数的时候，则构造WatchProcessor，否则构造IntervalProcessor，最后起一个goroutine。 go processor.Process() 这块的逻辑在本文第二部分析。 1.4. signalChan signalChan := make(chan os.Signal, 1) signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM) for { select { case err := 2. Process type Processor interface { Process() } Processor是一个接口类型，主要的实现体有： intervalProcessor：默认的实现体，即没有添加watch参数。 watchProcessor：添加watch参数的实现体。 2.1. intervalProcessor type intervalProcessor struct { config Config stopChan chan bool doneChan chan bool errChan chan error interval int } intervalProcessor根据config内容和几个channel构造一个intervalProcessor。 func IntervalProcessor(config Config, stopChan, doneChan chan bool, errChan chan error, interval int) Processor { return &intervalProcessor{config, stopChan, doneChan, errChan, interval} } 2.1.1. intervalProcessor.Process func (p *intervalProcessor) Process() { defer close(p.doneChan) for { ts, err := getTemplateResources(p.config) if err != nil { log.Fatal(err.Error()) break } process(ts) select { case 通过解析config内容获取TemplateResources，其中核心函数为process(ts)，然后执行t.process()，该函数中会调用t.sync()。t.process()的具体逻辑后文分析。 func process(ts []*TemplateResource) error { var lastErr error for _, t := range ts { if err := t.process(); err != nil { log.Error(err.Error()) lastErr = err } } return lastErr } 2.2. watchProcessor type watchProcessor struct { config Config stopChan chan bool doneChan chan bool errChan chan error wg sync.WaitGroup } watchProcessor根据config内容和几个channel构造一个watchProcessor。 func WatchProcessor(config Config, stopChan, doneChan chan bool, errChan chan error) Processor { var wg sync.WaitGroup return &watchProcessor{config, stopChan, doneChan, errChan, wg} } 2.2.1. watchProcessor.Process func (p *watchProcessor) Process() { defer close(p.doneChan) ts, err := getTemplateResources(p.config) if err != nil { log.Fatal(err.Error()) return } for _, t := range ts { t := t p.wg.Add(1) go p.monitorPrefix(t) } p.wg.Wait() } watchProcessor.Process方法实现了Processor接口中定义的方法，通过解析config内容获取TemplateResources，再遍历TemplateResources执行monitorPrefix，有多少个TemplateResources就运行多少个monitorPrefix的goroutine。 2.2.2. monitorPrefix func (p *watchProcessor) monitorPrefix(t *TemplateResource) { defer p.wg.Done() keys := util.AppendPrefix(t.Prefix, t.Keys) for { index, err := t.storeClient.WatchPrefix(t.Prefix, keys, t.lastIndex, p.stopChan) if err != nil { p.errChan 先对配置文件中的prefix和keys参数进行拼接。 keys := util.AppendPrefix(t.Prefix, t.Keys) AppendPrefix函数如下： func AppendPrefix(prefix string, keys []string) []string { s := make([]string, len(keys)) for i, k := range keys { s[i] = path.Join(prefix, k) } return s } 接着再执行storeClient的WatchPrefix方法，因为storeClient是一个接口，对应不同类型的存储后端，WatchPrefix的实现逻辑也不同，本文分析的存储类型为redis。 index, err := t.storeClient.WatchPrefix(t.Prefix, keys, t.lastIndex, p.stopChan) if err != nil { p.errChan storeClient.WatchPrefix主要是获取lastIndex的值，这个值在t.process()中使用。 t.lastIndex = index if err := t.process(); err != nil { p.errChan 2.3. TemplateResource.process 无论是否加watch参数，即intervalProcessor和watchProcessor最终都会调用到TemplateResource.process这个函数，而这个函数中的核心函数为t.sync()。 // process is a convenience function that wraps calls to the three main tasks // required to keep local configuration files in sync. First we gather vars // from the store, then we stage a candidate configuration file, and finally sync // things up. // It returns an error if any. func (t *TemplateResource) process() error { if err := t.setFileMode(); err != nil { return err } if err := t.setVars(); err != nil { return err } if err := t.createStageFile(); err != nil { return err } if err := t.sync(); err != nil { return err } return nil } 2.3.1. setFileMode setFileMode设置文件的权限，如果没有在配置文件指定mode参数则默认为0644，否则根据配置文件中指定的mode来设置文件权限。 // setFileMode sets the FileMode. func (t *TemplateResource) setFileMode() error { if t.Mode == \"\" { if !util.IsFileExist(t.Dest) { t.FileMode = 0644 } else { fi, err := os.Stat(t.Dest) if err != nil { return err } t.FileMode = fi.Mode() } } else { mode, err := strconv.ParseUint(t.Mode, 0, 32) if err != nil { return err } t.FileMode = os.FileMode(mode) } return nil } 2.3.2. setVars setVars将后端存储中最新的值拿出来暂存到内存中供后续进程使用。其中根据不同的后端，storeClient.GetValues的逻辑可能不同，但通过接口的方式可以让不同的存储后端实现不同的获取值的方法。 // setVars sets the Vars for template resource. func (t *TemplateResource) setVars() error { var err error log.Debug(\"Retrieving keys from store\") log.Debug(\"Key prefix set to \" + t.Prefix) result, err := t.storeClient.GetValues(util.AppendPrefix(t.Prefix, t.Keys)) if err != nil { return err } log.Debug(\"Got the following map from store: %v\", result) t.store.Purge() for k, v := range result { t.store.Set(path.Join(\"/\", strings.TrimPrefix(k, t.Prefix)), v) } return nil } 2.3.3. createStageFile createStageFile通过src的template文件和最新内存中的变量数据生成StageFile，该文件在sync中和目标文件进行比较，看是否有修改。即StageFile实际上是根据后端存储生成的最新的配置文件，如果这份配置文件跟当前的配置文件不同，表明后端存储的数据被更新了需要重新生成一份新的配置文件。 // createStageFile stages the src configuration file by processing the src // template and setting the desired owner, group, and mode. It also sets the // StageFile for the template resource. // It returns an error if any. func (t *TemplateResource) createStageFile() error { log.Debug(\"Using source template \" + t.Src) if !util.IsFileExist(t.Src) { return errors.New(\"Missing template: \" + t.Src) } log.Debug(\"Compiling source template \" + t.Src) tmpl, err := template.New(filepath.Base(t.Src)).Funcs(t.funcMap).ParseFiles(t.Src) if err != nil { return fmt.Errorf(\"Unable to process template %s, %s\", t.Src, err) } // create TempFile in Dest directory to avoid cross-filesystem issues temp, err := ioutil.TempFile(filepath.Dir(t.Dest), \".\"+filepath.Base(t.Dest)) if err != nil { return err } if err = tmpl.Execute(temp, nil); err != nil { temp.Close() os.Remove(temp.Name()) return err } defer temp.Close() // Set the owner, group, and mode on the stage file now to make it easier to // compare against the destination configuration file later. os.Chmod(temp.Name(), t.FileMode) os.Chown(temp.Name(), t.Uid, t.Gid) t.StageFile = temp return nil } 2.3.4. sync if err := t.sync(); err != nil { return err } t.sync()是执行confd核心功能的函数，将配置文件通过模板的方式自动生成，并执行检查命令和reload命令。该部分逻辑在本文第三部分分析。 3. sync sync通过比较源文件和目标文件的差别，如果不同则重新生成新的配置，当设置了check_cmd和reload_cmd的时候，会执行check_cmd指定的检查命令，如果都没有问题则执行reload_cmd中指定的reload命令。 3.1. IsConfigChanged IsConfigChanged比较源文件和目标文件是否相等，其中比较内容包括：Uid、Gid、Mode、Md5。只要其中任意值不同则认为两个文件不同。 // IsConfigChanged reports whether src and dest config files are equal. // Two config files are equal when they have the same file contents and // Unix permissions. The owner, group, and mode must match. // It return false in other cases. func IsConfigChanged(src, dest string) (bool, error) { if !IsFileExist(dest) { return true, nil } d, err := FileStat(dest) if err != nil { return true, err } s, err := FileStat(src) if err != nil { return true, err } if d.Uid != s.Uid { log.Info(fmt.Sprintf(\"%s has UID %d should be %d\", dest, d.Uid, s.Uid)) } if d.Gid != s.Gid { log.Info(fmt.Sprintf(\"%s has GID %d should be %d\", dest, d.Gid, s.Gid)) } if d.Mode != s.Mode { log.Info(fmt.Sprintf(\"%s has mode %s should be %s\", dest, os.FileMode(d.Mode), os.FileMode(s.Mode))) } if d.Md5 != s.Md5 { log.Info(fmt.Sprintf(\"%s has md5sum %s should be %s\", dest, d.Md5, s.Md5)) } if d.Uid != s.Uid || d.Gid != s.Gid || d.Mode != s.Mode || d.Md5 != s.Md5 { return true, nil } return false, nil } 如果文件发生改变则执行check_cmd命令（有配置的情况下），重新生成配置文件，并执行reload_cmd命令（有配置的情况下）。 if ok { log.Info(\"Target config \" + t.Dest + \" out of sync\") if !t.syncOnly && t.CheckCmd != \"\" { if err := t.check(); err != nil { return errors.New(\"Config check failed: \" + err.Error()) } } log.Debug(\"Overwriting target config \" + t.Dest) err := os.Rename(staged, t.Dest) if err != nil { if strings.Contains(err.Error(), \"device or resource busy\") { log.Debug(\"Rename failed - target is likely a mount. Trying to write instead\") // try to open the file and write to it var contents []byte var rerr error contents, rerr = ioutil.ReadFile(staged) if rerr != nil { return rerr } err := ioutil.WriteFile(t.Dest, contents, t.FileMode) // make sure owner and group match the temp file, in case the file was created with WriteFile os.Chown(t.Dest, t.Uid, t.Gid) if err != nil { return err } } else { return err } } if !t.syncOnly && t.ReloadCmd != \"\" { if err := t.reload(); err != nil { return err } } log.Info(\"Target config \" + t.Dest + \" has been updated\") } else { log.Debug(\"Target config \" + t.Dest + \" in sync\") } 3.2. check check检查暂存的配置文件即stageFile，该文件是由最新的后端存储中的数据生成的。 if !t.syncOnly && t.CheckCmd != \"\" { if err := t.check(); err != nil { return errors.New(\"Config check failed: \" + err.Error()) } } t.check()只是执行配置文件中checkcmd参数指定的命令而已，根据是否执行成功来返回报错。当check命令产生错误的是，则直接return报错，不再执行重新生成配置文件和`reload的操作了。 // check executes the check command to validate the staged config file. The // command is modified so that any references to src template are substituted // with a string representing the full path of the staged file. This allows the // check to be run on the staged file before overwriting the destination config // file. // It returns nil if the check command returns 0 and there are no other errors. func (t *TemplateResource) check() error { var cmdBuffer bytes.Buffer data := make(map[string]string) data[\"src\"] = t.StageFile.Name() tmpl, err := template.New(\"checkcmd\").Parse(t.CheckCmd) if err != nil { return err } if err := tmpl.Execute(&cmdBuffer, data); err != nil { return err } return runCommand(cmdBuffer.String()) } check会通过模板解析的方式解析出checkcmd中的{{.src}}部分，并用stageFile来替代。即check的命令是拉取最新后端存储的数据形成临时配置文件（stageFile），并通过指定的checkcmd来检查最新的临时配置文件是否合法，如果合法则替换会新的配置文件，否则返回错误。 3.3. Overwriting 将staged文件命名为Dest文件的名字，读取staged文件中的内容并将它写入到Dest文件中，该过程实际上就是重新生成一份新的配置文件。staged文件的生成逻辑在函数createStageFile中。 log.Debug(\"Overwriting target config \" + t.Dest) err := os.Rename(staged, t.Dest) if err != nil { if strings.Contains(err.Error(), \"device or resource busy\") { log.Debug(\"Rename failed - target is likely a mount. Trying to write instead\") // try to open the file and write to it var contents []byte var rerr error contents, rerr = ioutil.ReadFile(staged) if rerr != nil { return rerr } err := ioutil.WriteFile(t.Dest, contents, t.FileMode) // make sure owner and group match the temp file, in case the file was created with WriteFile os.Chown(t.Dest, t.Uid, t.Gid) if err != nil { return err } } else { return err } } 3.4. reload 如果没有指定syncOnly参数并且指定了ReloadCmd则执行reload操作。 if !t.syncOnly && t.ReloadCmd != \"\" { if err := t.reload(); err != nil { return err } } 其中t.reload()实现如下： // reload executes the reload command. // It returns nil if the reload command returns 0. func (t *TemplateResource) reload() error { return runCommand(t.ReloadCmd) } t.reload()和t.check()都调用了runCommand函数： // runCommand is a shared function used by check and reload // to run the given command and log its output. // It returns nil if the given cmd returns 0. // The command can be run on unix and windows. func runCommand(cmd string) error { log.Debug(\"Running \" + cmd) var c *exec.Cmd if runtime.GOOS == \"windows\" { c = exec.Command(\"cmd\", \"/C\", cmd) } else { c = exec.Command(\"/bin/sh\", \"-c\", cmd) } output, err := c.CombinedOutput() if err != nil { log.Error(fmt.Sprintf(\"%q\", string(output))) return err } log.Debug(fmt.Sprintf(\"%q\", string(output))) return nil } 4. redisClient.WatchPrefix redisClient.WatchPrefix是当用户设置了watch参数的时候，并且存储后端为redis，则会调用到redis的watch机制。其中redisClient.WatchPrefix是redis存储类型的时候实现了StoreClient接口的WatchPrefix方法。 // The StoreClient interface is implemented by objects that can retrieve // key/value pairs from a backend store. type StoreClient interface { GetValues(keys []string) (map[string]string, error) WatchPrefix(prefix string, keys []string, waitIndex uint64, stopChan chan bool) (uint64, error) } StoreClient是对后端存储类型的抽象，常用的后端存储类型有Etcd和Redis等，不同的后端存储类型GetValues和WatchPrefix的具体实现不同，本文主要分析Redis类型的watch机制。 4.1. WatchPrefix WatchPrefix的调用函数在monitorPrefix的部分，具体参考： func (p *watchProcessor) monitorPrefix(t *TemplateResource) { defer p.wg.Done() keys := util.AppendPrefix(t.Prefix, t.Keys) for { index, err := t.storeClient.WatchPrefix(t.Prefix, keys, t.lastIndex, p.stopChan) if err != nil { p.errChan redis的watch主要通过pub-sub的机制，即WatchPrefix会根据传入的prefix起一个sub的监听机制，而在写入redis的数据的同时需要执行redis的publish操作，channel为符合prefix的值，value为给定命令之一，实际上是给定命令之一，具体是什么命令并没有关系，则会触发watch机制，从而自动更新配置，给定的命令列表如下： \"del\", \"append\", \"rename_from\", \"rename_to\", \"expire\", \"set\", \"incrby\", \"incrbyfloat\", \"hset\", \"hincrby\", \"hincrbyfloat\", \"hdel\" sub监听的key的格式如下： __keyspace@0__:{prefix}/* 如果只是写入redis数据而没有自动执行publish的操作，并不会触发redis的watch机制来自动更新配置。但是如果使用etcd，则etcd的watch机制，只需要用户写入或更新数据就可以自动触发更新配置。 WatchPrefix源码如下： func (c *Client) WatchPrefix(prefix string, keys []string, waitIndex uint64, stopChan chan bool) (uint64, error) { if waitIndex == 0 { return 1, nil } if len(c.pscChan) > 0 { var respChan watchResponse for len(c.pscChan) > 0 { respChan = 5. 总结 confd的作用是通过将配置存放到存储后端，来自动触发更新配置的功能，其中常用的后端有Etcd和Redis等。 不同的存储后端，watch机制不同，例如Etcd只需要更新key便可以触发自动更新配置的操作，而redis除了更新key还需要执行publish的操作。 可以通过配置check_cmd来校验配置文件是否正确，如果配置文件非法则不会执行自动更新配置和reload的操作，但是当存储后端存入的非法数据，会导致每次校验都是失败的，即使后面新增的配置部分是合法的，所以需要有机制来控制存入存储后端的数据始终是合法的。 参考： https://github.com/kelseyhightower/confd/tree/v0.16.0 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-06-30 12:14:09 "}}